# Vaquita Security Review

- Security researcher: [@Rotcivegaf](https://github.com/rotcivegaf)
- Date From: 01/07/2025
- Date To: 29/07/2025
- Repository: [vaquita-fi/vaquita-lisk](https://github.com/vaquita-fi/vaquita-lisk/tree/c4964af9157c9cca9cfb167ac1a4450e36edb29e)
- Commit Hash: `c4964af9157c9cca9cfb167ac1a4450e36edb29e`

# Content

- [Disclaimer](#Disclaimer)
- [Scope](#Scope)
- [Risk Classification](#Risk-Classification)
     - [Impact](#Impact)
     - [Likelihood](#Likelihood)
- [Findings](#Findings)
     - [High](#High)
          - [[H-01] The `protocolFees` is set to `0` before the transfer](#h-01-the-protocolfees-is-set-to-0-before-the-transfer)
          - [[H-02] The user who makes a `withdraw` will take all the rewards](#h-02-The-user-who-makes-a-withdraw-will-take-all-the-rewards)
          - [[H-03] Discrepancy between amounts deposited and amounts to withdraw](#h-03-Discrepancy-between-amounts-deposited-and-amounts-to-withdraw)
          - [[H-04] A/B and 0/1 tokens do not always correspond to each other](#h-04-ab-and-01-tokens-do-not-always-correspond-to-each-other)
     - [Medium](#Medium)
          - [[M-01] Denial of service(DOS) on `deposit` function](#m-01-denial-of-servicedos-on-deposit-function)
          - [[M-02] Use `safeTransfer`/`safeTransferFrom` of library **SafeERC20** instead of `transfer`/`transferFrom` with unknown ERC20 tokens](#m-02-use-safetransfersafetransferfrom-of-library-safeerc20-instead-of-transfertransferfrom-with-unknown-erc20-tokens)
          - [[M-03] Use `forceApprove` of library **SafeERC20** instead of `approve` with unknown ERC20 tokens](#m-03-use-forceapprove-of-library-safeerc20-instead-of-approve-with-unknown-erc20-tokens)
          - [[M-04] Miss `isUni` parameter on `inputs` array](#m-04-miss-isuni-parameter-on-inputs-array)
          - [[M-05] MEV sandwich attack on `swap` function(`deposit` and `withdraw`)](#m-05-mev-sandwich-attack-on-swap-functiondeposit-and-withdraw)
          - [[M-06] MEV sandwich attack on `_decreaseAndCollectLiquidity` function(`withdraw`)](#m-06-mev-sandwich-attack-on-_decreaseandcollectliquidity-functionwithdraw)
          - [[M-07] MEV sandwich attack on `_addLiquidity` function(`deposit`)](#m-07-mev-sandwich-attack-on-_addliquidity-functiondeposit)
     - [Low](#Low)
          - [[L-01] Wrong revert error `InvalidFee` in `deposit` and `addRewards` function](#l-01-wrong-revert-error-invalidfee-in-deposit-and-addrewards-function)
          - [[L-02] The `withdrawProtocolFees` and `addRewards` functions should be usable even if the contract is paused](#l-02-the-withdrawprotocolfees-and-addrewards-functions-should-be-usable-even-if-the-contract-is-paused)
          - [[L-03] Missing `lockPeriod` attribute in the return of `getPosition` function](#l-03-missing-lockperiod-attribute-in-the-return-of-getposition-function)
          - [[L-04] Missing `_disableInitializers()` in VelodromeLiquidityManager constructor](#l-04-missing-_disableinitializers-in-velodromeliquiditymanager-constructor)
          - [[L-05] The variable `v3SwapExactIn` in VelodromeLiquidityManager contract could be hardcoded](#l-05-the-variable-v3swapexactin-in-velodromeliquiditymanager-contract-could-be-hardcoded)
          - [[L-06] Miss emit event when add protocol fees](#l-06-miss-emit-event-when-add-protocol-fees)
          - [[L-07] Attributes wrong/miss emitted on `FundsWithdrawn`](#l-07-attributes-wrongmiss-emitted-on-fundswithdrawn)
          - [[L-08] Hardcoded `deadline`](#l-08-hardcoded-deadline)
          - [[L-09] The `token` of VaquitaPool should be equal to `tokenA` or `tokenB` VelodromeLiquidityManager](#l-09-the-token-of-vaquitapool-should-be-equal-to-tokena-or-tokenb-velodromeliquiditymanager)
          - [[L-10] The `tokenA` and `tokenB` should be different](#l-10-the-tokena-and-tokenb-should-be-different)
          - [[L-11] Unsafe cast to `uint128`](#l-11-unsafe-cast-to-uint128)
          - [[L-12] The last parameter of `_decreaseAndCollectLiquidity` is not used](#l-12-the-last-parameter-of-_decreaseandcollectliquidity-is-not-used)
     - [Non-Critical](#non-critical)
          - [[NC-01] Unused events: `RewardDistributed` and `ProtocolFeesUpdated`](#nc-01-unused-events-rewarddistributed-and-protocolfeesupdated)
          - [[NC-02] Unnecessary default assignation](#nc-02-unnecessary-default-assignation)
          - [[NC-03] Redundant functions: `getPosition` and `getUserDeposit`](#nc-03-redundant-functions-getposition-and-getuserdeposit)
          - [[NC-04] Redundant attribute/mapping: `totalDeposits`/`userTotalDepositsPerLockPeriod`](#nc-04-redundant-attributemapping-totaldepositsusertotaldepositsperlockperiod)
          - [[NC-05] Wrong struct `Deposit` on VelodromeLiquidityManager interface](#nc-05-wrong-struct-deposit-on-velodromeliquiditymanager-interface)
          - [[NC-06] Complex `lockPeriods` array](#nc-06-complex-lockperiods-array)
          - [[NC-07] Redundant attribute `id` on struct `Position`](#nc-07-redundant-attribute-id-on-struct-position)
          - [[NC-08] Reorder and optimization on the `if` of `withdraw` function](#nc-08-reorder-and-optimization-on-the-if-of-withdraw-function)
          - [[NC-09] Redundant attribute `isActive` on struct `Position`](#nc-09-redundant-attribute-isactive-on-struct-position)
          - [[NC-10] Redundant attribute `entryTime` on struct `Position`](#nc-10-redundant-attribute-entrytime-on-struct-position)
          - [[NC-11] Avoid one-line functions with contract call](#nc-11-avoid-one-line-functions-with-contract-call)
          - [[NC-12] Redundant attributes on struct `Deposit`](#nc-12-redundant-attributes-on-struct-deposit)
          - [[NC-13] Redundant mapping `userDepositIds`](#nc-13-redundant-mapping-userdepositids)

## Disclaimer

A smart contract security review can never verify the complete absence of vulnerabilities. This is a time, resource and expertise bound effort where we try to ﬁnd as many vulnerabilities as possible. We can not guarantee 100% security after the review or even if the review will ﬁnd any problems with your smart contracts. Subsequent security reviews, bug bounty programs and on-chain monitoring are strongly recommended.

## Scope

- [VaquitaPool.sol](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol)
- [VelodromeLiquidityManager.sol](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.soll)

## Risk Classification

| Likelihood \ Severity | High Impact | Medium Impact | Low Impact |
|-----------------------|-------------|---------------|------------|
| High                  | Critical    | High          | Medium     |
| Medium                | High        | Medium        | Low        |
| Low                   | Medium      | Low           | Low        |

### Impact

- High: Leads to a significant material loss of assets in the protocol or significantly
harms a group of users.
- Medium: Only a small amount of funds can be lost (such as leakage of value) or a
core functionality of the protocol is affected.
- Low: Can lead to any kind of unexpected behavior with some of the protocol's
functionalities that's not so critical.

### Likelihood

- High: Attack path is possible with reasonable assumptions that mimic on-chain
conditions, and the cost of the attack is relatively low compared to the amount of
funds that can be stolen or lost.
- Medium: Only a conditionally incentivized attack vector, but still relatively
likely.
- Low: Has too many or too unlikely assumptions or requires a significant stake by
the attacker with little or no incentive.

## Findings

| Severity           | Amount   |
|--------------------|----------|
| High               |   4      |
| Medium             |   7      |
| Low                |  12      |
| Non-Critical       |  13      |
| **Total Findings** | **36**   |

## High

### [H-01] The `protocolFees` is set to `0` before the transfer

- Impact: Medium
- Likelihood: High

#### Code Snippets

- [VaquitaPool.sol#L274-L281](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L274-L281)

#### Description

```solidity
    function withdrawProtocolFees() external onlyOwner whenNotPaused {
        protocolFees = 0;
        token.safeTransfer(owner(), protocolFees);
        emit ProtocolFeesWithdrawn(protocolFees);
    }
```

As we can see in the `withdrawProtocolFees` function of the VaquitaPool contract, the `protocolFees` is set to `0` before sending funds to the `owner`, causing these funds to be locked within the contract.

#### Impact Details

Locking of protocol fees in the contract.

#### Recommendation

Proposal Fix: [PR #1](https://github.com/vaquita-fi/vaquita-lisk/pull/1/files)

- File: contracts/src/VaquitaPool.sol
```diff
@@ -275,9 +275,10 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
     * @notice Withdraw protocol fees to the contract owner
     */
     function withdrawProtocolFees() external onlyOwner whenNotPaused {
+        uint256 cacheProtocolFees = protocolFees;
         protocolFees = 0;
-        token.safeTransfer(owner(), protocolFees);
-        emit ProtocolFeesWithdrawn(protocolFees);
+        token.safeTransfer(owner(), cacheProtocolFees);
+        emit ProtocolFeesWithdrawn(cacheProtocolFees);
     }

     /**
```

### [H-02] The user who makes a `withdraw` will take all the rewards

- Impact: Medium
- Likelihood: High

#### Code Snippets

- [VelodromeLiquidityManager.sol#L125-L134](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L125-L134)

#### Description

When performing the `collect` on the `nonfungiblePositionManager`, the parameters `amount0Max` and `amount1Max` are set to `amount0` and `amount1`. This means that the user obtains a maximum of `amount0` and `amount1`, which is greater than the proportion of tokens corresponding to their shares.

#### Impact Details

The user who makes a `withdraw` will take all the rewards earned up to that point.

#### Recommendation

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -109,7 +109,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      */
     function _decreaseAndCollectLiquidity(uint256 shares) internal returns (uint256 collectedAmount0, uint256 collectedAmount1, uint128 liquidityToRemove) {
         if (totalShares == 0) return (0, 0, 0);
-        (, , , , , , , uint128 totalPositionLiquidity, , , , ) = nonfungiblePositionManager.positions(positionTokenId);
+        (, , , , , , , uint128 totalPositionLiquidity, , , uint128 tokensOwed0, uint128 tokensOwed1) = nonfungiblePositionManager.positions(positionTokenId);
         liquidityToRemove = uint128((shares * totalPositionLiquidity) / totalShares);
         totalShares -= shares;
 
@@ -122,14 +122,14 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         });
 
         // Step 1: Decrease liquidity (this only updates the position, doesn't transfer tokens)
-        (uint256 amount0, uint256 amount1) = nonfungiblePositionManager.decreaseLiquidity(params);
+        nonfungiblePositionManager.decreaseLiquidity(params);
         
         // Step 2: Collect the tokens from the position
         CollectParams memory collectParams = CollectParams({
             tokenId: positionTokenId,
             recipient: address(this), // Collect to this contract first
-            amount0Max: SafeCast.toUint128(amount0),
-            amount1Max: SafeCast.toUint128(amount1)
+            amount0Max: SafeCast.toUint128((shares * tokensOwed0) / totalShares),
+            amount1Max: SafeCast.toUint128((shares * tokensOwed1) / totalShares)
         });
         (collectedAmount0, collectedAmount1) = nonfungiblePositionManager.collect(collectParams);
     }
```

### [H-03] Discrepancy between amounts deposited and amounts to withdraw

- Impact: Medium
- Likelihood: High

#### Code Snippets

- [VelodromeLiquidityManager.sol#L260-L273](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L260-L273)

#### Description

When executing a `withdraw`, the contract performs a decrease liquidity and finally exchanges the amount of `tokenA` for `tokenB` and transfers it to the user.
However, due to balance changes in the pool when performing `decreaseLiquidity`, the amounts initially deposited (`Deposit.amount0Remaining` and `Deposit.amount1Remaining`) may differ from those returned when performing `decreaseLiquidity`.
This will generate a discrepancy between the amounts deposited and obtained.

#### Impact Details

Discrepancy between amounts deposited and amounts to withdraw.

#### Recommendation

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -105,12 +105,11 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param shares The shares to remove
      * @return collectedAmount0 Amount of token0 collected
      * @return collectedAmount1 Amount of token1 collected
-     * @return liquidityToRemove The liquidity removed
      */
-    function _decreaseAndCollectLiquidity(uint256 shares) internal returns (uint256 collectedAmount0, uint256 collectedAmount1, uint128 liquidityToRemove) {
-        if (totalShares == 0) return (0, 0, 0);
+    function _decreaseAndCollectLiquidity(uint256 shares) internal returns (uint256 collectedAmount0, uint256 collectedAmount1, uint256 amount0, uint256 amount1) {
+        if (totalShares == 0) return (0, 0, 0, 0);
         (, , , , , , , uint128 totalPositionLiquidity, , , , ) = nonfungiblePositionManager.positions(positionTokenId);
-        liquidityToRemove = uint128((shares * totalPositionLiquidity) / totalShares);
+        uint128 liquidityToRemove = uint128((shares * totalPositionLiquidity) / totalShares);
         totalShares -= shares;
 
         DecreaseLiquidityParams memory params = DecreaseLiquidityParams({
@@ -122,7 +121,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         });
 
         // Step 1: Decrease liquidity (this only updates the position, doesn't transfer tokens)
-        (uint256 amount0, uint256 amount1) = nonfungiblePositionManager.decreaseLiquidity(params);
+        (amount0, amount1) = nonfungiblePositionManager.decreaseLiquidity(params);
         
         // Step 2: Collect the tokens from the position
         CollectParams memory collectParams = CollectParams({
@@ -255,10 +254,10 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
 
         depositToWithdraw.isActive = false;
 
-        (uint256 collectedAmount0, uint256 collectedAmount1, ) = _decreaseAndCollectLiquidity(shares);
+        (uint256 collectedAmount0, uint256 collectedAmount1, uint256 amount0, uint256 amount1) = _decreaseAndCollectLiquidity(shares);
 
-        uint256 finalTokenAAmount = collectedAmount1 + depositToWithdraw.amount1Remaining;
-        uint256 finalTokenBAmount = collectedAmount0 + depositToWithdraw.amount0Remaining;
+        uint256 finalTokenAAmount = collectedAmount1 + amount1;
+        uint256 finalTokenBAmount = collectedAmount0 + amount0;
 
         if (finalTokenBAmount > 0) {
             uint256 tokenABalanceBeforeSwap = IERC20(tokenA).balanceOf(address(this));
```

### [H-04] A/B and 0/1 tokens do not always correspond to each other

- Impact: High
- Likelihood: High

#### Code Snippets

- [VelodromeLiquidityManager.sol#L32-L33](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L32-L33)

#### Description

In the `VelodromeLiquidityManager` contract, exchanges are made between `tokenA` and `tokenB`, and liquidity is also added or removed from the pool.
When the contract is initialized, tokens A and B may not be ordered, which means that tokens 0 and 1 within the nonfungiblePositionManager pool do not correspond to A and B.

#### Impact Details

Lock funds in the contract

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -216,7 +216,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @return sharesToMint The number of shares minted.
      */
     function _supplyToVelodrome(bytes16 depositId, uint256 amount) internal returns (uint256 sharesToMint) {
-        sharesToMint = liquidityManager.deposit(depositId, amount);
+        sharesToMint = liquidityManager.deposit(depositId, address(token), amount);
     }
 
     /**
@@ -226,7 +226,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @return withdrawnAmount The amount of tokens withdrawn.
      */
     function _withdrawFromVelodrome(bytes16 depositId) internal returns (uint256 withdrawnAmount) {
-        withdrawnAmount = liquidityManager.withdraw(depositId);
+        withdrawnAmount = liquidityManager.withdraw(depositId, address(token));
     }
 
     /**
```

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -29,8 +29,8 @@ struct Deposit {
 }
 
 contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {
-    address public tokenA;
-    address public tokenB;
+    address public token0;
+    address public token1;
     IUniversalRouter public universalRouter;
     INonfungiblePositionManager public nonfungiblePositionManager;
     uint8 public v3SwapExactIn;
@@ -55,8 +55,8 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
 
     /**
      * @notice Contract constructor
-     * @param _tokenA Address of tokenA
-     * @param _tokenB Address of tokenB
+     * @param _token0 Address of token0
+     * @param _token1 Address of token1
      * @param _universalRouter Address of the universal router
      * @param _nonfungiblePositionManager Address of the position manager
      * @param _v3SwapExactIn Swap command byte
@@ -65,8 +65,8 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param _tickUpper Upper tick for the position
      */
     function initialize(
-        address _tokenA,
-        address _tokenB,
+        address _token0,
+        address _token1,
         address _universalRouter,
         address _nonfungiblePositionManager,
         uint8 _v3SwapExactIn,
@@ -77,19 +77,20 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         __Ownable_init(msg.sender);
         __Pausable_init();
         __ReentrancyGuard_init();
-        if (_tokenA == address(0) || _tokenB == address(0) || _universalRouter == address(0) || _nonfungiblePositionManager == address(0)) revert InvalidAddress();
-        tokenA = _tokenA;
-        tokenB = _tokenB;
+        if (_token0 == address(0) || _token1 == address(0) || _universalRouter == address(0) || _nonfungiblePositionManager == address(0)) revert InvalidAddress();
+        require(_token0 < _token1, "The tokens are not sorted");
+        token0 = _token0;
+        token1 = _token1;
         v3SwapExactIn = _v3SwapExactIn;
         tickSpacing = _tickSpacing;
         tickLower = _tickLower;
         tickUpper = _tickUpper;
         universalRouter = IUniversalRouter(_universalRouter);
         nonfungiblePositionManager = INonfungiblePositionManager(_nonfungiblePositionManager);
-        IERC20(tokenA).approve(address(universalRouter), type(uint256).max);
-        IERC20(tokenB).approve(address(universalRouter), type(uint256).max);
-        IERC20(tokenA).approve(address(nonfungiblePositionManager), type(uint256).max);
-        IERC20(tokenB).approve(address(nonfungiblePositionManager), type(uint256).max);
+        IERC20(token0).approve(address(universalRouter), type(uint256).max);
+        IERC20(token1).approve(address(universalRouter), type(uint256).max);
+        IERC20(token0).approve(address(nonfungiblePositionManager), type(uint256).max);
+        IERC20(token1).approve(address(nonfungiblePositionManager), type(uint256).max);
     }
 
     function pause() external onlyOwner {
@@ -151,24 +152,28 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
     }
 
     /**
-     * @notice Deposit tokenA, swap half for tokenB, and add liquidity
+     * @notice Deposit token0, swap half for token1, and add liquidity
      * @param depositId The unique deposit ID
-     * @param amount The amount of tokenA to deposit
+     * @param amountA The amountA of tokenA to deposit
      */
-    function deposit(bytes16 depositId, uint256 amount) external nonReentrant whenNotPaused returns (uint256) {
+    function deposit(bytes16 depositId, address tokenA, uint256 amountA) external nonReentrant whenNotPaused returns (uint256) {
         require(depositId != 0, "Deposit ID cannot be zero");
         require(userDepositDetails[msg.sender][depositId].shares == 0, "Deposit ID already exists for user");
-        require(amount > 0, "Deposit amount must be greater than 0");
-        IERC20(tokenA).transferFrom(msg.sender, address(this), amount);
+        require(amountA > 0, "Deposit amountA must be greater than 0");
 
-        uint256 swapAmount = amount / 2;
+        address tokenB;
+        (tokenA, tokenB) = _orderToken(tokenA);
+
+        IERC20(tokenA).transferFrom(msg.sender, address(this), amountA);
+
+        uint256 swapAmount = amountA / 2;
         uint256 balanceBBefore = IERC20(tokenB).balanceOf(address(this));
         swap(tokenA, tokenB, swapAmount);
         uint256 balanceBAfter = IERC20(tokenB).balanceOf(address(this));
         uint256 amountB = balanceBAfter - balanceBBefore;
 
-        uint256 sharesToMint = _addLiquidity(amount - swapAmount, amountB, msg.sender, depositId);
-        emit FundsDeposited(msg.sender, depositId, amount - swapAmount, amountB, sharesToMint);
+        uint256 sharesToMint = _addLiquidity(tokenA, tokenB, amountA - swapAmount, amountB, msg.sender, depositId);
+        emit FundsDeposited(msg.sender, depositId, amountA - swapAmount, amountB, sharesToMint);
         return sharesToMint;
     }
 
@@ -179,7 +184,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param depositor The user address
      * @param depositId The deposit ID
      */
-    function _addLiquidity(uint256 amountA, uint256 amountB, address depositor, bytes16 depositId) internal returns (uint256) {
+    function _addLiquidity(address tokenA, address tokenB, uint256 amountA, uint256 amountB, address depositor, bytes16 depositId) internal returns (uint256) {
         // No need to approve here due to approve-once pattern
         uint256 sharesToMint;
         uint256 amount0Used;
@@ -188,13 +193,13 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         if (positionTokenId == 0) {
             // mint a new position when there is no position yet
             MintParams memory params = MintParams({
-                token0: tokenB,
-                token1: tokenA,
+                token0: tokenA,
+                token1: tokenB,
                 tickSpacing: int24(tickSpacing),
                 tickLower: tickLower,
                 tickUpper: tickUpper,
-                amount0Desired: amountB,
-                amount1Desired: amountA,
+                amount0Desired: amountA,
+                amount1Desired: amountB,
                 amount0Min: 0, 
                 amount1Min: 0,
                 recipient: address(this),
@@ -202,40 +207,35 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
                 sqrtPriceX96: 0
             });
 
-            (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1) = nonfungiblePositionManager.mint(params);
-            positionTokenId = tokenId;
-            sharesToMint = liquidity;
-            amount0Used = amount0;
-            amount1Used = amount1;
+            (positionTokenId, sharesToMint, amount0Used, amount1Used) = nonfungiblePositionManager.mint(params);
         } else {
             // add liquidity to an existing position
             (, , , , , , , uint128 totalLiquidity, , , , ) = nonfungiblePositionManager.positions(positionTokenId);
 
             IncreaseLiquidityParams memory params = IncreaseLiquidityParams({
                 tokenId: positionTokenId,
-                amount0Desired: amountB,
-                amount1Desired: amountA,
+                amount0Desired: amountA,
+                amount1Desired: amountB,
                 amount0Min: 0,
                 amount1Min: 0,
                 deadline: block.timestamp
             });
-            (uint128 addedLiquidity, uint256 amount0, uint256 amount1) = nonfungiblePositionManager.increaseLiquidity(params);
-            
+            uint256 addedLiquidity;
+            (addedLiquidity, amount0Used, amount1Used) = nonfungiblePositionManager.increaseLiquidity(params);
+    
             sharesToMint = totalLiquidity > 0 ? (addedLiquidity * totalShares) / totalLiquidity : addedLiquidity;
-            amount0Used = amount0;
-            amount1Used = amount1;
         }
 
         totalShares += sharesToMint;
         userDepositDetails[depositor][depositId] = Deposit({
             id: depositId,
             shares: sharesToMint,
-            amount0Contributed: amountB,
-            amount1Contributed: amountA,
+            amount0Contributed: amountA,
+            amount1Contributed: amountB,
             amount0Used: amount0Used,
             amount1Used: amount1Used,
-            amount0Remaining: amountB - amount0Used,
-            amount1Remaining: amountA - amount1Used,
+            amount0Remaining: amountA - amount0Used,
+            amount1Remaining: amountB - amount1Used,
             isActive: true
         });
         userDepositIds[depositor].push(depositId);
@@ -244,10 +244,10 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
     }
 
     /**
-     * @notice Withdraw a user's deposit, remove liquidity, swap back to tokenA, and transfer to user
+     * @notice Withdraw a user's deposit, remove liquidity, swap back to token0, and transfer to user
      * @param depositId The deposit ID to withdraw
      */
-    function withdraw(bytes16 depositId) external nonReentrant whenNotPaused returns (uint256) {
+    function withdraw(bytes16 depositId, address tokenA) external nonReentrant whenNotPaused returns (uint256) {
         Deposit storage depositToWithdraw = userDepositDetails[msg.sender][depositId];
         uint256 shares = depositToWithdraw.shares;
         require(depositToWithdraw.isActive, "Deposit is not active");
@@ -255,10 +255,13 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
 
         depositToWithdraw.isActive = false;
 
-        (uint256 collectedAmount0, uint256 collectedAmount1, ) = _decreaseAndCollectLiquidity(shares);
+        (uint256 collectedAmountA, uint256 collectedAmountB, ) = _decreaseAndCollectLiquidity(shares);
 
-        uint256 finalTokenAAmount = collectedAmount1 + depositToWithdraw.amount1Remaining;
-        uint256 finalTokenBAmount = collectedAmount0 + depositToWithdraw.amount0Remaining;
+        uint256 finalTokenAAmount = collectedAmountA + depositToWithdraw.amount0Remaining;
+        uint256 finalTokenBAmount = collectedAmountB + depositToWithdraw.amount1Remaining;
+
+        address tokenB;
+        (tokenA, tokenB) = _orderToken(tokenA);
 
         if (finalTokenBAmount > 0) {
             uint256 tokenABalanceBeforeSwap = IERC20(tokenA).balanceOf(address(this));
@@ -293,4 +296,14 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
     function getUserDepositIds(address user) external view returns (bytes16[] memory) {
         return userDepositIds[user];
     }
+
+    function _orderToken(address token) internal view returns(address tokenA, address tokenB) {
+        if (token == token0) {
+            return (token0, token1);
+        } else if (token == token1) {
+            return (token1, token0); // Switch
+        } else {
+            revert("Wrong token");
+        }
+    }
 }
```

- File: contracts/src/interfaces/IVelodromeLiquidityManager.sol
```diff
@@ -27,14 +27,14 @@ interface IVelodromeLiquidityManager {
      * @param amount The amount of tokenA to deposit
      * @return sharesToMint The number of shares minted for this deposit
      */
-    function deposit(bytes16 _depositId, uint256 amount) external returns (uint256 sharesToMint);
+    function deposit(bytes16 _depositId, address token, uint256 amount) external returns (uint256 sharesToMint);
 
     /**
      * @notice Withdraw a user's deposit, remove liquidity, swap back to tokenA, and transfer to user
      * @param depositId The deposit ID to withdraw
      * @return finalTokenAAmount The final amount of tokenA returned to the user
      */
-    function withdraw(bytes16 depositId) external returns (uint256 finalTokenAAmount);
+    function withdraw(bytes16 depositId, address token) external returns (uint256 finalTokenAAmount);
 
     /**
      * @notice Get a user's deposit struct by depositId
```

## Medium

### [M-01] Denial of service(DOS) on `deposit` function

- Impact: Medium
- Likelihood: Medium

#### Code Snippets

- [VaquitaPool.solL123-L126](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L123-L126)

#### Description

```solidity
    function deposit(bytes16 depositId, uint256 amount, uint256 period, uint256 deadline, bytes memory signature) external nonReentrant whenNotPaused returns (uint256 sharesToMint) {
        if (amount == 0) revert InvalidAmount();
        if (depositId == bytes16(0)) revert InvalidDepositId();
        if (positions[depositId].id != bytes16(0)) revert DepositAlreadyExists();
        if (!isSupportedLockPeriod(period)) revert InvalidFee();
```

As we can see in the `deposit` function of the VaquitaPool contract, the `depositId` is provided by the sender.
This makes it possible for a malicious actor to copy the `depositId` of a transaction in the mempool and frontrun the transaction using the same `depositId` as the first transaction.
This causes the first transaction reverts.

#### Impact Details

Denial of service(DOS) on `deposit` function

#### Recommendation

Proposal Fix: [PR #3](https://github.com/vaquita-fi/vaquita-lisk/pull/3/files)

- File: contracts/src/VaquitaPool.sol
```diff
@@ -19,7 +19,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
 
     // Position struct to store user position information
     struct Position {
-        bytes16 id;
+        bytes32 id;
         address owner;
         uint256 amount;
         uint256 shares;
@@ -47,12 +47,13 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
     mapping(address => mapping(uint256 => uint256)) public userTotalDepositsPerLockPeriod; // user => lockPeriod => total deposits
     
     // Mappings
-    mapping(bytes16 => Position) public positions;
+    mapping(address => uint256) public depositNonces;
+    mapping(bytes32 => Position) public positions;
 
     // Events
-    event FundsDeposited(bytes16 indexed depositId, address indexed owner, uint256 amount, uint256 shares);
-    event FundsWithdrawn(bytes16 indexed depositId, address indexed owner, uint256 amount, uint256 reward);
-    event RewardDistributed(bytes16 indexed depositId, address indexed owner, uint256 reward);
+    event FundsDeposited(bytes32 indexed depositId, address indexed owner, uint256 amount, uint256 shares);
+    event FundsWithdrawn(bytes32 indexed depositId, address indexed owner, uint256 amount, uint256 reward);
+    event RewardDistributed(bytes32 indexed depositId, address indexed owner, uint256 reward);
     event LockPeriodAdded(uint256 newLockPeriod);
     event EarlyWithdrawalFeeUpdated(uint256 newFee);
     event RewardsAdded(uint256 rewardAmount);
@@ -114,16 +115,14 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
     /**
      * @notice Open a new position in the pool
      * @dev Allows a user to deposit tokens, which are supplied to the VelodromeLiquidityManager. Position is tracked by a unique depositId.
-     * @param depositId The unique identifier for the position
      * @param amount The amount of tokens to deposit
      * @param period The lock period chosen for this deposit
      * @param deadline The deadline for the permit signature
      * @param signature The permit signature for token approval
      */
-    function deposit(bytes16 depositId, uint256 amount, uint256 period, uint256 deadline, bytes memory signature) external nonReentrant whenNotPaused returns (uint256 sharesToMint) {
+    function deposit(uint256 amount, uint256 period, uint256 deadline, bytes memory signature) external nonReentrant whenNotPaused returns (uint256 sharesToMint) {
+        bytes32 depositId = keccak256(abi.encodePacked(msg.sender, depositNonces[msg.sender]++));
         if (amount == 0) revert InvalidAmount();
-        if (depositId == bytes16(0)) revert InvalidDepositId();
-        if (positions[depositId].id != bytes16(0)) revert DepositAlreadyExists();
         if (!isSupportedLockPeriod(period)) revert InvalidFee();
 
         // Create position
@@ -166,9 +165,9 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @dev Only the position owner can withdraw. Handles early withdrawal fees and reward distribution.
      * @param depositId The ID of the position to withdraw from
      */
-    function withdraw(bytes16 depositId) external nonReentrant whenNotPaused returns (uint256 amountToTransfer) {
+    function withdraw(bytes32 depositId) external nonReentrant whenNotPaused returns (uint256 amountToTransfer) {
         Position storage position = positions[depositId];
-        if (position.id == bytes16(0)) revert PositionNotFound();
+        if (position.id == bytes32(0)) revert PositionNotFound();
         if (!position.isActive) revert PositionAlreadyWithdrawn();
         if (position.owner != msg.sender) revert NotPositionOwner();
 
@@ -215,7 +214,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @param amount The amount of tokens to supply.
      * @return sharesToMint The number of shares minted.
      */
-    function _supplyToVelodrome(bytes16 depositId, uint256 amount) internal returns (uint256 sharesToMint) {
+    function _supplyToVelodrome(bytes32 depositId, uint256 amount) internal returns (uint256 sharesToMint) {
         sharesToMint = liquidityManager.deposit(depositId, amount);
     }
 
@@ -225,7 +224,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @param depositId The unique identifier for the position.
      * @return withdrawnAmount The amount of tokens withdrawn.
      */
-    function _withdrawFromVelodrome(bytes16 depositId) internal returns (uint256 withdrawnAmount) {
+    function _withdrawFromVelodrome(bytes32 depositId) internal returns (uint256 withdrawnAmount) {
         withdrawnAmount = liquidityManager.withdraw(depositId);
     }
 
@@ -239,7 +238,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @return finalizationTime The finalization time
      * @return positionIsActive Whether the position is active
      */
-    function getPosition(bytes16 depositId) external view returns (
+    function getPosition(bytes32 depositId) external view returns (
         address positionOwner,
         uint256 positionAmount,
         uint256 shares,
```

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -17,7 +17,7 @@ import {ReentrancyGuardUpgradeable} from "@openzeppelin/contracts-upgradeable/ut
 import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
 
 struct Deposit {
-    bytes16 id;
+    bytes32 id;
     uint256 shares;
     uint256 amount0Contributed;
     uint256 amount1Contributed;
@@ -42,13 +42,13 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
     uint256 public totalShares;
 
     // Track each deposit for every user
-    mapping(address => mapping(bytes16 => Deposit)) public userDepositDetails;
-    mapping(address => bytes16[]) public userDepositIds;
+    mapping(address => mapping(bytes32 => Deposit)) public userDepositDetails;
+    mapping(address => bytes32[]) public userDepositIds;
 
     /// @notice Emitted when a user makes a deposit
-    event FundsDeposited(address indexed user, bytes16 indexed depositId, uint256 amountA, uint256 amountB, uint256 shares);
+    event FundsDeposited(address indexed user, bytes32 indexed depositId, uint256 amountA, uint256 amountB, uint256 shares);
     /// @notice Emitted when a user withdraws
-    event FundsWithdrawn(address indexed user, bytes16 indexed depositId, uint256 amountA);
+    event FundsWithdrawn(address indexed user, bytes32 indexed depositId, uint256 amountA);
 
     // Errors
     error InvalidAddress();
@@ -155,7 +155,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param depositId The unique deposit ID
      * @param amount The amount of tokenA to deposit
      */
-    function deposit(bytes16 depositId, uint256 amount) external nonReentrant whenNotPaused returns (uint256) {
+    function deposit(bytes32 depositId, uint256 amount) external nonReentrant whenNotPaused returns (uint256) {
         require(depositId != 0, "Deposit ID cannot be zero");
         require(userDepositDetails[msg.sender][depositId].shares == 0, "Deposit ID already exists for user");
         require(amount > 0, "Deposit amount must be greater than 0");
@@ -179,7 +179,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param depositor The user address
      * @param depositId The deposit ID
      */
-    function _addLiquidity(uint256 amountA, uint256 amountB, address depositor, bytes16 depositId) internal returns (uint256) {
+    function _addLiquidity(uint256 amountA, uint256 amountB, address depositor, bytes32 depositId) internal returns (uint256) {
         // No need to approve here due to approve-once pattern
         uint256 sharesToMint;
         uint256 amount0Used;
@@ -247,7 +247,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @notice Withdraw a user's deposit, remove liquidity, swap back to tokenA, and transfer to user
      * @param depositId The deposit ID to withdraw
      */
-    function withdraw(bytes16 depositId) external nonReentrant whenNotPaused returns (uint256) {
+    function withdraw(bytes32 depositId) external nonReentrant whenNotPaused returns (uint256) {
         Deposit storage depositToWithdraw = userDepositDetails[msg.sender][depositId];
         uint256 shares = depositToWithdraw.shares;
         require(depositToWithdraw.isActive, "Deposit is not active");
@@ -281,7 +281,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param depositId The deposit ID
      * @return The Deposit struct
      */
-    function getUserDeposit(address user, bytes16 depositId) external view returns (Deposit memory) {
+    function getUserDeposit(address user, bytes32 depositId) external view returns (Deposit memory) {
         return userDepositDetails[user][depositId];
     }
 
@@ -290,7 +290,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param user The user address
      * @return Array of deposit IDs
      */
-    function getUserDepositIds(address user) external view returns (bytes16[] memory) {
+    function getUserDepositIds(address user) external view returns (bytes32[] memory) {
         return userDepositIds[user];
     }
 }
```

- File: contracts/src/interfaces/IVelodromeLiquidityManager.sol
```diff
@@ -3,7 +3,7 @@ pragma solidity 0.8.30;
 
 /// @notice Struct for user deposit tracking
 struct Deposit {
-    bytes16 id;
+    bytes32 id;
     uint256 shares;
     uint256 amount0Contributed;
     uint256 amount1Contributed;
@@ -17,9 +17,9 @@ struct Deposit {
 /// @notice Interface for VelodromeLiquidityManager
 interface IVelodromeLiquidityManager {
     /// @notice Emitted when a user makes a deposit
-    event FundsDeposited(address indexed user, bytes16 indexed depositId, uint256 amountA, uint256 amountB, uint256 shares);
+    event FundsDeposited(address indexed user, bytes32 indexed depositId, uint256 amountA, uint256 amountB, uint256 shares);
     /// @notice Emitted when a user withdraws
-    event FundsWithdrawn(address indexed user, bytes16 indexed depositId, uint256 amountA);
+    event FundsWithdrawn(address indexed user, bytes32 indexed depositId, uint256 amountA);
 
     /**
      * @notice Deposit tokenA, swap half for tokenB, and add liquidity
@@ -27,14 +27,14 @@ interface IVelodromeLiquidityManager {
      * @param amount The amount of tokenA to deposit
      * @return sharesToMint The number of shares minted for this deposit
      */
-    function deposit(bytes16 _depositId, uint256 amount) external returns (uint256 sharesToMint);
+    function deposit(bytes32 _depositId, uint256 amount) external returns (uint256 sharesToMint);
 
     /**
      * @notice Withdraw a user's deposit, remove liquidity, swap back to tokenA, and transfer to user
      * @param depositId The deposit ID to withdraw
      * @return finalTokenAAmount The final amount of tokenA returned to the user
      */
-    function withdraw(bytes16 depositId) external returns (uint256 finalTokenAAmount);
+    function withdraw(bytes32 depositId) external returns (uint256 finalTokenAAmount);
 
     /**
      * @notice Get a user's deposit struct by depositId
@@ -42,12 +42,12 @@ interface IVelodromeLiquidityManager {
      * @param depositId The deposit ID
      * @return The Deposit struct
      */
-    function getUserDeposit(address user, bytes16 depositId) external view returns (Deposit memory);
+    function getUserDeposit(address user, bytes32 depositId) external view returns (Deposit memory);
 
     /**
      * @notice Get all deposit IDs for a user
      * @param user The user address
      * @return Array of deposit IDs
      */
-    function getUserDepositIds(address user) external view returns (bytes16[] memory);
+    function getUserDepositIds(address user) external view returns (bytes32[] memory);
 }
```

### [M-02] Use `safeTransfer`/`safeTransferFrom` of library **SafeERC20** instead of `transfer`/`transferFrom` with unknown ERC20 tokens 

- Impact: Medium
- Likelihood: Medium

#### Code Snippets

- [VelodromeLiquidityManager.sol#L162](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L162)
- [VelodromeLiquidityManager.sol#L272](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L272)

#### Description

The `deposit` and `withdraw` functions of VelodromeLiquidityManager contract, performs an ERC20 `transfer`/`transferFrom` but does not check the return value, nor does it work with all legacy tokens.
Some tokens (like **USDT**) don’t correctly implement the **EIP20** standard and their `transfer`/`transferFrom` function return void instead of a success boolean. Calling these functions with the correct **EIP20** function signatures will always revert.
The `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter needs to be checked for success.
Some tokens do not revert if the transfer failed but return false instead.

#### Impact Details

The `deposit` and `withdraw` functions of VelodromeLiquidityManager contract cannot use non standard **EIP20** tokens

#### Recommendation

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -3,6 +3,7 @@ pragma solidity 0.8.30;
 
 import {IUniversalRouter} from "./interfaces/external/IUniversalRouter.sol";
 import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
+import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
 import {
     INonfungiblePositionManager,
     MintParams,
@@ -29,6 +30,8 @@ struct Deposit {
 }
 
 contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {
+    using SafeERC20 for IERC20;
+
     address public tokenA;
     address public tokenB;
     IUniversalRouter public universalRouter;
@@ -159,7 +162,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         require(depositId != 0, "Deposit ID cannot be zero");
         require(userDepositDetails[msg.sender][depositId].shares == 0, "Deposit ID already exists for user");
         require(amount > 0, "Deposit amount must be greater than 0");
-        IERC20(tokenA).transferFrom(msg.sender, address(this), amount);
+        IERC20(tokenA).safeTransferFrom(msg.sender, address(this), amount);
 
         uint256 swapAmount = amount / 2;
         uint256 balanceBBefore = IERC20(tokenB).balanceOf(address(this));
@@ -269,7 +272,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         }
 
         if (finalTokenAAmount > 0) {
-            IERC20(tokenA).transfer(msg.sender, finalTokenAAmount);
+            IERC20(tokenA).safeTransfer(msg.sender, finalTokenAAmount);
         }
         emit FundsWithdrawn(msg.sender, depositId, finalTokenAAmount);
         return finalTokenAAmount;
```

### [M-03] Use `forceApprove` of library **SafeERC20** instead of `approve` with unknown ERC20 tokens 

- Impact: Medium
- Likelihood: Medium

#### Code Snippets

- [VaquitaPool.sol#L95](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L95)
- [VelodromeLiquidityManager.sol#L89-L92](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L89-L92)

#### Description

The `initialize` functions of VaquitaPool and VelodromeLiquidityManager contracts performs an ERC20 `approve` but does not check the return value, nor does it work with all legacy tokens.
Some tokens (like **USDT**) don’t correctly implement the **EIP20** standard and their `approve` function return void instead of a success boolean. Calling these functions with the correct **EIP20** function signatures will always revert.
The `ERC20.approve()` functions return a boolean value indicating success. This parameter needs to be checked for success.
Some tokens do not revert if the transfer failed but return false instead.

#### Impact Details

The VaquitaPool and VelodromeLiquidityManager contracts could not be initialize with non standard **EIP20** tokens.

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -92,7 +92,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         token = IERC20(_token);
         liquidityManager = IVelodromeLiquidityManager(_liquidityManager);
         lockPeriods = _lockPeriods;
-        token.approve(address(liquidityManager), type(uint256).max);
+        token.forceApprove(address(liquidityManager), type(uint256).max);
     }
 
     /**
```

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -3,6 +3,7 @@ pragma solidity 0.8.30;
 
 import {IUniversalRouter} from "./interfaces/external/IUniversalRouter.sol";
 import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
+import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
 import {
     INonfungiblePositionManager,
     MintParams,
@@ -29,6 +30,8 @@ struct Deposit {
 }
 
 contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {
+    using SafeERC20 for IERC20;
+
     address public tokenA;
     address public tokenB;
     IUniversalRouter public universalRouter;
@@ -86,10 +89,10 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         tickUpper = _tickUpper;
         universalRouter = IUniversalRouter(_universalRouter);
         nonfungiblePositionManager = INonfungiblePositionManager(_nonfungiblePositionManager);
-        IERC20(tokenA).approve(address(universalRouter), type(uint256).max);
-        IERC20(tokenB).approve(address(universalRouter), type(uint256).max);
-        IERC20(tokenA).approve(address(nonfungiblePositionManager), type(uint256).max);
-        IERC20(tokenB).approve(address(nonfungiblePositionManager), type(uint256).max);
+        IERC20(tokenA).forceApprove(address(universalRouter), type(uint256).max);
+        IERC20(tokenB).forceApprove(address(universalRouter), type(uint256).max);
+        IERC20(tokenA).forceApprove(address(nonfungiblePositionManager), type(uint256).max);
+        IERC20(tokenB).forceApprove(address(nonfungiblePositionManager), type(uint256).max);
     }
 
     function pause() external onlyOwner {
```

### [M-04] Miss `isUni` parameter on `inputs` array

#### Code Snippets

- [VelodromeLiquidityManager.sol#L149](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L149)

#### Description

[`// equivalent: abi.decode(inputs, (address, uint256, uint256, bytes, bool, bool))`](https://github.com/velodrome-finance/universal-router/blob/3e83bc1f24dfce978ab0a5cf08279621280e316b/contracts/base/Dispatcher.sol#L72)

As we can see in this line of code, UniversalRouter uses Dispatcher, which executes a swap.
This swap has the parameter `isUni`:
- If is `true`: The swap is routed through Uniswap pools.
- If is `false`: The swap is routed through Velodrome Finance or Slipstream pools.

`inputs[0] = abi.encode(address(this), amountIn, amountOutMin, path, true);`

Within the `swap` function of VelodromeLiquidityManager, the `execute` function of UniversalRouter is called without the `isUni` parameter within the array of inputs.

In this case, `execute` reads the byte outside the `inputs` array. Since the `deadline` parameter is after the array and is a timestamp, the first byte is `0`, which would give `isUni = false`.

#### Recommendation

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -37,6 +37,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
     int24 public tickSpacing;
     int24 public tickLower;
     int24 public tickUpper;
+    bool public isUni; // true for Uniswap, false for Velodrome
 
     uint256 public positionTokenId;
     uint256 public totalShares;
@@ -72,7 +73,8 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         uint8 _v3SwapExactIn,
         int24 _tickSpacing,
         int24 _tickLower,
-        int24 _tickUpper
+        int24 _tickUpper,
+        bool _isUni
     ) external initializer {
         __Ownable_init(msg.sender);
         __Pausable_init();
@@ -84,6 +86,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         tickSpacing = _tickSpacing;
         tickLower = _tickLower;
         tickUpper = _tickUpper;
+        isUni = _isUni;
         universalRouter = IUniversalRouter(_universalRouter);
         nonfungiblePositionManager = INonfungiblePositionManager(_nonfungiblePositionManager);
         IERC20(tokenA).approve(address(universalRouter), type(uint256).max);
@@ -146,7 +149,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         bytes memory commands = abi.encodePacked(bytes1(v3SwapExactIn));
         bytes memory path = abi.encodePacked(fromToken, tickSpacing, toToken);
         bytes[] memory inputs = new bytes[](1);
-        inputs[0] = abi.encode(address(this), amountIn, amountOutMin, path, true);
+        inputs[0] = abi.encode(address(this), amountIn, amountOutMin, path, true, isUni);
         universalRouter.execute(commands, inputs, block.timestamp);
     }
```

### [M-05] MEV sandwich attack on `swap` function(`deposit` and `withdraw`)

#### Code Snippets

- [VelodromeLiquidityManager.sol#L143-L151](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L143-L151)

#### Description

```solidity
    function swap(address fromToken, address toToken, uint256 amountIn) internal {
        // No need to approve here due to approve-once pattern
        uint256 amountOutMin = 0;
        bytes memory commands = abi.encodePacked(bytes1(v3SwapExactIn));
        bytes memory path = abi.encodePacked(fromToken, tickSpacing, toToken);
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encode(address(this), amountIn, amountOutMin, path, true);
        universalRouter.execute(commands, inputs, block.timestamp);
    }
```

As we can see, when performing the swap, the `amountOutMin` is `0`, this makes the function vulnerable to sandwich attacks since it expects the return of `toToken` to be at least `0`.
It is very common for MEV bots to monitor the mempool in search of these opportunities. Upon detecting a transaction with this advantage, the MEV performs a swap, changing the price of the `toToken`, sends the user's transaction, and then performs a reverse swap, generating a profit for the MEV bot.

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -120,7 +120,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @param deadline The deadline for the permit signature
      * @param signature The permit signature for token approval
      */
-    function deposit(bytes16 depositId, uint256 amount, uint256 period, uint256 deadline, bytes memory signature) external nonReentrant whenNotPaused returns (uint256 sharesToMint) {
+    function deposit(bytes16 depositId, uint256 amount, uint256 amountOutMin, uint256 period, uint256 deadline, bytes memory signature) external nonReentrant whenNotPaused returns (uint256 sharesToMint) {
         if (amount == 0) revert InvalidAmount();
         if (depositId == bytes16(0)) revert InvalidDepositId();
         if (positions[depositId].id != bytes16(0)) revert DepositAlreadyExists();
@@ -148,7 +148,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         token.safeTransferFrom(msg.sender, address(this), amount);
 
         // Supply to Velodrome
-        sharesToMint = _supplyToVelodrome(depositId, amount);
+        sharesToMint = _supplyToVelodrome(depositId, amount, amountOutMin);
         
         // AUDIT NOTE: This state change after external call is safe because:
         // 1. nonReentrant modifier prevents reentrancy
@@ -166,7 +166,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @dev Only the position owner can withdraw. Handles early withdrawal fees and reward distribution.
      * @param depositId The ID of the position to withdraw from
      */
-    function withdraw(bytes16 depositId) external nonReentrant whenNotPaused returns (uint256 amountToTransfer) {
+    function withdraw(bytes16 depositId, uint256 amountOutMin) external nonReentrant whenNotPaused returns (uint256 amountToTransfer) {
         Position storage position = positions[depositId];
         if (position.id == bytes16(0)) revert PositionNotFound();
         if (!position.isActive) revert PositionAlreadyWithdrawn();
@@ -177,7 +177,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         position.isActive = false;
 
         // Withdraw from Velodrome and get actual amount received
-        uint256 withdrawnAmount = _withdrawFromVelodrome(depositId);
+        uint256 withdrawnAmount = _withdrawFromVelodrome(depositId, amountOutMin);
         uint256 interest = withdrawnAmount > position.amount ? withdrawnAmount - position.amount : 0;
 
         uint256 reward = 0;
@@ -215,8 +215,8 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @param amount The amount of tokens to supply.
      * @return sharesToMint The number of shares minted.
      */
-    function _supplyToVelodrome(bytes16 depositId, uint256 amount) internal returns (uint256 sharesToMint) {
-        sharesToMint = liquidityManager.deposit(depositId, amount);
+    function _supplyToVelodrome(bytes16 depositId, uint256 amount, uint256 amountOutMin) internal returns (uint256 sharesToMint) {
+        sharesToMint = liquidityManager.deposit(depositId, amount, amountOutMin);
     }
 
     /**
@@ -225,8 +225,8 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @param depositId The unique identifier for the position.
      * @return withdrawnAmount The amount of tokens withdrawn.
      */
-    function _withdrawFromVelodrome(bytes16 depositId) internal returns (uint256 withdrawnAmount) {
-        withdrawnAmount = liquidityManager.withdraw(depositId);
+    function _withdrawFromVelodrome(bytes16 depositId, uint256 amountOutMin) internal returns (uint256 withdrawnAmount) {
+        withdrawnAmount = liquidityManager.withdraw(depositId, amountOutMin);
     }
 
     /**
```

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -140,14 +140,15 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param toToken The token to swap to
      * @param amountIn The amount to swap
      */
-    function swap(address fromToken, address toToken, uint256 amountIn) internal {
+    function swap(address fromToken, address toToken, uint256 amountIn, uint256 amountOutMin) internal {
         // No need to approve here due to approve-once pattern
-        uint256 amountOutMin = 0;
         bytes memory commands = abi.encodePacked(bytes1(v3SwapExactIn));
         bytes memory path = abi.encodePacked(fromToken, tickSpacing, toToken);
         bytes[] memory inputs = new bytes[](1);
-        inputs[0] = abi.encode(address(this), amountIn, amountOutMin, path, true);
+        inputs[0] = abi.encode(address(this), amountIn, amountOutMin, path, true, false);
         universalRouter.execute(commands, inputs, block.timestamp);
+
+        //abi.decode(inputs, (address, uint256, uint256, bytes, bool, bool))
     }
 
     /**
@@ -155,7 +156,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param depositId The unique deposit ID
      * @param amount The amount of tokenA to deposit
      */
-    function deposit(bytes16 depositId, uint256 amount) external nonReentrant whenNotPaused returns (uint256) {
+    function deposit(bytes16 depositId, uint256 amount, uint256 amountOutMin) external nonReentrant whenNotPaused returns (uint256) {
         require(depositId != 0, "Deposit ID cannot be zero");
         require(userDepositDetails[msg.sender][depositId].shares == 0, "Deposit ID already exists for user");
         require(amount > 0, "Deposit amount must be greater than 0");
@@ -163,7 +164,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
 
         uint256 swapAmount = amount / 2;
         uint256 balanceBBefore = IERC20(tokenB).balanceOf(address(this));
-        swap(tokenA, tokenB, swapAmount);
+        swap(tokenA, tokenB, swapAmount, amountOutMin);
         uint256 balanceBAfter = IERC20(tokenB).balanceOf(address(this));
         uint256 amountB = balanceBAfter - balanceBBefore;
 
@@ -247,7 +248,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @notice Withdraw a user's deposit, remove liquidity, swap back to tokenA, and transfer to user
      * @param depositId The deposit ID to withdraw
      */
-    function withdraw(bytes16 depositId) external nonReentrant whenNotPaused returns (uint256) {
+    function withdraw(bytes16 depositId, uint256 amountOutMin) external nonReentrant whenNotPaused returns (uint256) {
         Deposit storage depositToWithdraw = userDepositDetails[msg.sender][depositId];
         uint256 shares = depositToWithdraw.shares;
         require(depositToWithdraw.isActive, "Deposit is not active");
@@ -262,7 +263,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
 
         if (finalTokenBAmount > 0) {
             uint256 tokenABalanceBeforeSwap = IERC20(tokenA).balanceOf(address(this));
-            swap(tokenB, tokenA, finalTokenBAmount);
+            swap(tokenB, tokenA, finalTokenBAmount, amountOutMin);
             uint256 tokenABalanceAfterSwap = IERC20(tokenA).balanceOf(address(this));
             uint256 swappedAmountA = tokenABalanceAfterSwap - tokenABalanceBeforeSwap;
             finalTokenAAmount += swappedAmountA;
```

- File: contracts/src/interfaces/IVelodromeLiquidityManager.sol
```diff
@@ -27,14 +27,14 @@ interface IVelodromeLiquidityManager {
      * @param amount The amount of tokenA to deposit
      * @return sharesToMint The number of shares minted for this deposit
      */
-    function deposit(bytes16 _depositId, uint256 amount) external returns (uint256 sharesToMint);
+    function deposit(bytes16 _depositId, uint256 amount, uint256 amountOutMin) external returns (uint256 sharesToMint);
 
     /**
      * @notice Withdraw a user's deposit, remove liquidity, swap back to tokenA, and transfer to user
      * @param depositId The deposit ID to withdraw
      * @return finalTokenAAmount The final amount of tokenA returned to the user
      */
-    function withdraw(bytes16 depositId) external returns (uint256 finalTokenAAmount);
+    function withdraw(bytes16 depositId, uint256 amountOutMin) external returns (uint256 finalTokenAAmount);
 
     /**
      * @notice Get a user's deposit struct by depositId
```

### [M-06] MEV sandwich attack on `_decreaseAndCollectLiquidity` function(`withdraw`)

#### Code Snippets

- [VelodromeLiquidityManager.sol#L119-L120](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L119-L120)

#### Description

```solidity
        DecreaseLiquidityParams memory params = DecreaseLiquidityParams({
            tokenId: positionTokenId,
            liquidity: liquidityToRemove,
            amount0Min: 0,
            amount1Min: 0,
            deadline: block.timestamp
        });

        // Step 1: Decrease liquidity (this only updates the position, doesn't transfer tokens)
        (uint256 amount0, uint256 amount1) = nonfungiblePositionManager.decreaseLiquidity(params);
```

As we can see, when performing the decreaseLiquidity, the `amount0Min` and `amount1Min` are `0`, this makes the function vulnerable to sandwich attacks since it expects the amount returned of the token0 and token1 to be at least `0`.
It is very common for MEV bots to monitor the mempool in search of these opportunities. Upon detecting a transaction with this advantage, the MEV performs a changing the balance of the pool, sends the user's transaction, and then rebalance the pool, generating a profit for the MEV bot.

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -166,7 +166,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @dev Only the position owner can withdraw. Handles early withdrawal fees and reward distribution.
      * @param depositId The ID of the position to withdraw from
      */
-    function withdraw(bytes16 depositId) external nonReentrant whenNotPaused returns (uint256 amountToTransfer) {
+    function withdraw(bytes16 depositId, uint256 amount0Min, uint256 amount1Min) external nonReentrant whenNotPaused returns (uint256 amountToTransfer) {
         Position storage position = positions[depositId];
         if (position.id == bytes16(0)) revert PositionNotFound();
         if (!position.isActive) revert PositionAlreadyWithdrawn();
@@ -177,7 +177,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         position.isActive = false;
 
         // Withdraw from Velodrome and get actual amount received
-        uint256 withdrawnAmount = _withdrawFromVelodrome(depositId);
+        uint256 withdrawnAmount = _withdrawFromVelodrome(depositId, amount0Min, amount1Min);
         uint256 interest = withdrawnAmount > position.amount ? withdrawnAmount - position.amount : 0;
 
         uint256 reward = 0;
@@ -225,8 +225,8 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @param depositId The unique identifier for the position.
      * @return withdrawnAmount The amount of tokens withdrawn.
      */
-    function _withdrawFromVelodrome(bytes16 depositId) internal returns (uint256 withdrawnAmount) {
-        withdrawnAmount = liquidityManager.withdraw(depositId);
+    function _withdrawFromVelodrome(bytes16 depositId, uint256 amount0Min, uint256 amount1Min) internal returns (uint256 withdrawnAmount) {
+        withdrawnAmount = liquidityManager.withdraw(depositId, amount0Min, amount1Min);
     }
 
     /**
```

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -107,7 +107,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @return collectedAmount1 Amount of token1 collected
      * @return liquidityToRemove The liquidity removed
      */
-    function _decreaseAndCollectLiquidity(uint256 shares) internal returns (uint256 collectedAmount0, uint256 collectedAmount1, uint128 liquidityToRemove) {
+    function _decreaseAndCollectLiquidity(uint256 shares, uint256 amount0Min, uint256 amount1Min) internal returns (uint256 collectedAmount0, uint256 collectedAmount1, uint128 liquidityToRemove) {
         if (totalShares == 0) return (0, 0, 0);
         (, , , , , , , uint128 totalPositionLiquidity, , , , ) = nonfungiblePositionManager.positions(positionTokenId);
         liquidityToRemove = uint128((shares * totalPositionLiquidity) / totalShares);
@@ -116,8 +116,8 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         DecreaseLiquidityParams memory params = DecreaseLiquidityParams({
             tokenId: positionTokenId,
             liquidity: liquidityToRemove,
-            amount0Min: 0,
-            amount1Min: 0,
+            amount0Min: amount0Min,
+            amount1Min: amount1Min,
             deadline: block.timestamp
         });
 
@@ -247,7 +247,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @notice Withdraw a user's deposit, remove liquidity, swap back to tokenA, and transfer to user
      * @param depositId The deposit ID to withdraw
      */
-    function withdraw(bytes16 depositId) external nonReentrant whenNotPaused returns (uint256) {
+    function withdraw(bytes16 depositId, uint256 amount0Min, uint256 amount1Min) external nonReentrant whenNotPaused returns (uint256) {
         Deposit storage depositToWithdraw = userDepositDetails[msg.sender][depositId];
         uint256 shares = depositToWithdraw.shares;
         require(depositToWithdraw.isActive, "Deposit is not active");
@@ -255,7 +255,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
 
         depositToWithdraw.isActive = false;
 
-        (uint256 collectedAmount0, uint256 collectedAmount1, ) = _decreaseAndCollectLiquidity(shares);
+        (uint256 collectedAmount0, uint256 collectedAmount1, ) = _decreaseAndCollectLiquidity(shares, amount0Min, amount1Min);
 
         uint256 finalTokenAAmount = collectedAmount1 + depositToWithdraw.amount1Remaining;
         uint256 finalTokenBAmount = collectedAmount0 + depositToWithdraw.amount0Remaining;
```

- File: contracts/src/interfaces/IVelodromeLiquidityManager.sol
```diff
@@ -34,7 +34,7 @@ interface IVelodromeLiquidityManager {
      * @param depositId The deposit ID to withdraw
      * @return finalTokenAAmount The final amount of tokenA returned to the user
      */
-    function withdraw(bytes16 depositId) external returns (uint256 finalTokenAAmount);
+    function withdraw(bytes16 depositId, uint256 amount0Min, uint256 amount1Min) external returns (uint256 finalTokenAAmount);
 
     /**
      * @notice Get a user's deposit struct by depositId
```

### [M-07] MEV sandwich attack on `_addLiquidity` function(`deposit`)

#### Code Snippets

- [VelodromeLiquidityManager.sol#L190-L205](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L190-L205)
- [VelodromeLiquidityManager.sol#L214-L222](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L214-L222)

#### Description

```solidity
            MintParams memory params = MintParams({
                token0: tokenB,
                token1: tokenA,
                tickSpacing: int24(tickSpacing),
                tickLower: tickLower,
                tickUpper: tickUpper,
                amount0Desired: amountB,
                amount1Desired: amountA,
                amount0Min: 0, 
                amount1Min: 0,
                recipient: address(this),
                deadline: block.timestamp,
                sqrtPriceX96: 0
            });

            (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1) = nonfungiblePositionManager.mint(params);
```

```solidity
            IncreaseLiquidityParams memory params = IncreaseLiquidityParams({
                tokenId: positionTokenId,
                amount0Desired: amountB,
                amount1Desired: amountA,
                amount0Min: 0,
                amount1Min: 0,
                deadline: block.timestamp
            });
            (uint128 addedLiquidity, uint256 amount0, uint256 amount1) = nonfungiblePositionManager.increaseLiquidity(params);
```

As we can see in both cases, `amount0Min` and `amount1Min` are `0`, this makes the function vulnerable to sandwich attacks.
It is very common for MEV bots to monitor the mempool in search of these opportunities. Upon detecting a transaction with this advantage, the MEV performs a changing the balance of the pool, sends the user's transaction, and then rebalance the pool, generating a profit for the MEV bot.

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -120,7 +120,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @param deadline The deadline for the permit signature
      * @param signature The permit signature for token approval
      */
-    function deposit(bytes16 depositId, uint256 amount, uint256 period, uint256 deadline, bytes memory signature) external nonReentrant whenNotPaused returns (uint256 sharesToMint) {
+    function deposit(bytes16 depositId, uint256 amount, uint256 period, uint256 deadline, uint256 amount0Min, uint256 amount1Min, bytes memory signature) external nonReentrant whenNotPaused returns (uint256 sharesToMint) {
         if (amount == 0) revert InvalidAmount();
         if (depositId == bytes16(0)) revert InvalidDepositId();
         if (positions[depositId].id != bytes16(0)) revert DepositAlreadyExists();
@@ -148,7 +148,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         token.safeTransferFrom(msg.sender, address(this), amount);
 
         // Supply to Velodrome
-        sharesToMint = _supplyToVelodrome(depositId, amount);
+        sharesToMint = _supplyToVelodrome(depositId, amount, amount0Min, amount1Min);
         
         // AUDIT NOTE: This state change after external call is safe because:
         // 1. nonReentrant modifier prevents reentrancy
@@ -215,8 +215,8 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @param amount The amount of tokens to supply.
      * @return sharesToMint The number of shares minted.
      */
-    function _supplyToVelodrome(bytes16 depositId, uint256 amount) internal returns (uint256 sharesToMint) {
-        sharesToMint = liquidityManager.deposit(depositId, amount);
+    function _supplyToVelodrome(bytes16 depositId, uint256 amount, uint256 amount0Min, uint256 amount1Min) internal returns (uint256 sharesToMint) {
+        sharesToMint = liquidityManager.deposit(depositId, amount, amount0Min, amount1Min);
     }
 
     /**
```

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -155,7 +155,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param depositId The unique deposit ID
      * @param amount The amount of tokenA to deposit
      */
-    function deposit(bytes16 depositId, uint256 amount) external nonReentrant whenNotPaused returns (uint256) {
+    function deposit(bytes16 depositId, uint256 amount, uint256 amount0Min, uint256 amount1Min) external nonReentrant whenNotPaused returns (uint256) {
         require(depositId != 0, "Deposit ID cannot be zero");
         require(userDepositDetails[msg.sender][depositId].shares == 0, "Deposit ID already exists for user");
         require(amount > 0, "Deposit amount must be greater than 0");
@@ -167,7 +167,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         uint256 balanceBAfter = IERC20(tokenB).balanceOf(address(this));
         uint256 amountB = balanceBAfter - balanceBBefore;
 
-        uint256 sharesToMint = _addLiquidity(amount - swapAmount, amountB, msg.sender, depositId);
+        uint256 sharesToMint = _addLiquidity(amount - swapAmount, amountB, msg.sender, depositId, amount0Min, amount1Min);
         emit FundsDeposited(msg.sender, depositId, amount - swapAmount, amountB, sharesToMint);
         return sharesToMint;
     }
@@ -179,7 +179,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param depositor The user address
      * @param depositId The deposit ID
      */
-    function _addLiquidity(uint256 amountA, uint256 amountB, address depositor, bytes16 depositId) internal returns (uint256) {
+    function _addLiquidity(uint256 amountA, uint256 amountB, address depositor, bytes16 depositId, uint256 amount0Min, uint256 amount1Min) internal returns (uint256) {
         // No need to approve here due to approve-once pattern
         uint256 sharesToMint;
         uint256 amount0Used;
@@ -195,8 +195,8 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
                 tickUpper: tickUpper,
                 amount0Desired: amountB,
                 amount1Desired: amountA,
-                amount0Min: 0, 
-                amount1Min: 0,
+                amount0Min: amount0Min, 
+                amount1Min: amount1Min,
                 recipient: address(this),
                 deadline: block.timestamp,
                 sqrtPriceX96: 0
@@ -215,8 +215,8 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
                 tokenId: positionTokenId,
                 amount0Desired: amountB,
                 amount1Desired: amountA,
-                amount0Min: 0,
-                amount1Min: 0,
+                amount0Min: amount0Min,
+                amount1Min: amount1Min,
                 deadline: block.timestamp
             });
             (uint128 addedLiquidity, uint256 amount0, uint256 amount1) = nonfungiblePositionManager.increaseLiquidity(params);
```

- File: contracts/src/interfaces/IVelodromeLiquidityManager.sol
```diff
@@ -27,7 +27,7 @@ interface IVelodromeLiquidityManager {
      * @param amount The amount of tokenA to deposit
      * @return sharesToMint The number of shares minted for this deposit
      */
-    function deposit(bytes16 _depositId, uint256 amount) external returns (uint256 sharesToMint);
+    function deposit(bytes16 _depositId, uint256 amount, uint256 amount0Min, uint256 amount1Min) external returns (uint256 sharesToMint);
 
     /**
      * @notice Withdraw a user's deposit, remove liquidity, swap back to tokenA, and transfer to user
```

## Low

### [L-01] Wrong revert error `InvalidFee` in `deposit` and `addRewards` function

#### Code Snippets

- [VaquitaPool.sol#L127](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L127)
- [VaquitaPool.sol#L289](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L289)

#### Description

The `deposit` and `addRewards` functions of the VaquitaPool contract are reversed with the error `InvalidFee()` and should be `InvalidPeriod()`.

#### Recommendation

Proposal Fix: [PR #2](https://github.com/vaquita-fi/vaquita-lisk/pull/2/files)

- File: contracts/src/VaquitaPool.sol
```diff
@@ -65,6 +65,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
     error NotPositionOwner();
     error InvalidAddress();
     error InvalidFee();
+    error PeriodNotSupported();
     error InvalidDepositId();
     error DepositAlreadyExists();
 
@@ -124,7 +125,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         if (amount == 0) revert InvalidAmount();
         if (depositId == bytes16(0)) revert InvalidDepositId();
         if (positions[depositId].id != bytes16(0)) revert DepositAlreadyExists();
-        if (!isSupportedLockPeriod(period)) revert InvalidFee();
+        if (!isSupportedLockPeriod(period)) revert PeriodNotSupported();
 
         // Create position
         Position storage position = positions[depositId];
@@ -286,7 +287,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @param rewardAmount The amount of rewards to add
      */
     function addRewards(uint256 period, uint256 rewardAmount) external onlyOwner whenNotPaused {
-        if (!isSupportedLockPeriod(period)) revert InvalidFee();
+        if (!isSupportedLockPeriod(period)) revert PeriodNotSupported();
         token.safeTransferFrom(msg.sender, address(this), rewardAmount);
         periods[period].rewardPool += rewardAmount;
         emit RewardsAdded(rewardAmount);
```

### [L-02] The `withdrawProtocolFees` and `addRewards` functions should be usable even if the contract is paused

#### Code Snippets

- [VaquitaPool.sol#L277](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L277)
- [VaquitaPool.sol#L288](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L288)

#### Description

The `withdrawProtocolFees` and `addRewards` functions should be usable even if the contract is paused, since they are `onlyOwner`

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -274,7 +274,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
     /**
      * @notice Withdraw protocol fees to the contract owner
      */
-    function withdrawProtocolFees() external onlyOwner whenNotPaused {
+    function withdrawProtocolFees() external onlyOwner {
         protocolFees = 0;
         token.safeTransfer(owner(), protocolFees);
         emit ProtocolFeesWithdrawn(protocolFees);
@@ -285,7 +285,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @param period The lock period to add rewards to
      * @param rewardAmount The amount of rewards to add
      */
-    function addRewards(uint256 period, uint256 rewardAmount) external onlyOwner whenNotPaused {
+    function addRewards(uint256 period, uint256 rewardAmount) external onlyOwner {
         if (!isSupportedLockPeriod(period)) revert InvalidFee();
         token.safeTransferFrom(msg.sender, address(this), rewardAmount);
         periods[period].rewardPool += rewardAmount;
```

### [L-03] Missing `lockPeriod` attribute in the return of `getPosition` function

#### Code Snippets

- [VaquitaPool.sol#L232-L259](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L232-L259)

#### Description

```solidity
    struct Position {
        bytes16 id;
        address owner;
        uint256 amount;
        uint256 shares;
        uint256 entryTime;
        uint256 finalizationTime;
        bool isActive;
        uint256 lockPeriod;
    }
```

As we can see, the `Position` struct has the `lockPeriod` attribute, but in the `getPosition` function, it is not returned

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -245,7 +245,8 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         uint256 shares,
         uint256 entryTime,
         uint256 finalizationTime,
-        bool positionIsActive
+        bool positionIsActive,
+        uint256 lockPeriod
     ) {
         Position storage position = positions[depositId];
         return (
@@ -254,7 +255,8 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
             position.shares,
             position.entryTime,
             position.finalizationTime,
-            position.isActive
+            position.isActive,
+            position.lockPeriod
         );
     }
```

### [L-04] Missing `_disableInitializers()` in VelodromeLiquidityManager constructor

#### Description

The VelodromeLiquidityManager contract is upgradeable but does not call `_disableInitializers` in its constructor. In upgradeable contract patterns, this call is a best practice to prevent the implementation (logic) contract from being initialized directly.

While this doesn’t affect the proxy’s behavior, it helps protect against accidental or malicious use of the implementation contract in isolation, especially in environments where both proxy and implementation contracts are visible, like block explorers.

#### Recommendation

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -53,6 +53,11 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
     // Errors
     error InvalidAddress();
 
+    /// @custom:oz-upgrades-unsafe-allow constructor
+    constructor() {
+        _disableInitializers();
+    }
+
     /**
      * @notice Contract constructor
      * @param _tokenA Address of tokenA
```

### [L-05] The variable `v3SwapExactIn` in VelodromeLiquidityManager contract could be hardcoded

#### Recommendation

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -33,7 +33,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
     address public tokenB;
     IUniversalRouter public universalRouter;
     INonfungiblePositionManager public nonfungiblePositionManager;
-    uint8 public v3SwapExactIn;
+    bytes public commands = abi.encodePacked(bytes1(0));
     int24 public tickSpacing;
     int24 public tickLower;
     int24 public tickUpper;
@@ -59,7 +59,6 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param _tokenB Address of tokenB
      * @param _universalRouter Address of the universal router
      * @param _nonfungiblePositionManager Address of the position manager
-     * @param _v3SwapExactIn Swap command byte
      * @param _tickSpacing Tick spacing for the pool
      * @param _tickLower Lower tick for the position
      * @param _tickUpper Upper tick for the position
@@ -69,7 +68,6 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         address _tokenB,
         address _universalRouter,
         address _nonfungiblePositionManager,
-        uint8 _v3SwapExactIn,
         int24 _tickSpacing,
         int24 _tickLower,
         int24 _tickUpper
@@ -80,7 +78,6 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         if (_tokenA == address(0) || _tokenB == address(0) || _universalRouter == address(0) || _nonfungiblePositionManager == address(0)) revert InvalidAddress();
         tokenA = _tokenA;
         tokenB = _tokenB;
-        v3SwapExactIn = _v3SwapExactIn;
         tickSpacing = _tickSpacing;
         tickLower = _tickLower;
         tickUpper = _tickUpper;
@@ -143,7 +140,6 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
     function swap(address fromToken, address toToken, uint256 amountIn) internal {
         // No need to approve here due to approve-once pattern
         uint256 amountOutMin = 0;
-        bytes memory commands = abi.encodePacked(bytes1(v3SwapExactIn));
         bytes memory path = abi.encodePacked(fromToken, tickSpacing, toToken);
         bytes[] memory inputs = new bytes[](1);
         inputs[0] = abi.encode(address(this), amountIn, amountOutMin, path, true);
```

### [L-06] Miss emit event when add protocol fees

#### Code Snippets

- [VaquitaPool.sol#L189](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L189)

#### Description

In the `withdraw` function, a fee is charged for early withdrawal but no event is emitted. 
I assume that the event to be emit is `ProtocolFeesUpdated`, although I recommend that the fee charged in the transaction be issued and not the total fee.

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -57,6 +57,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
     event EarlyWithdrawalFeeUpdated(uint256 newFee);
     event RewardsAdded(uint256 rewardAmount);
     event ProtocolFeesUpdated(uint256 newProtocolFees);
+    event AddProtocolFees(uint256 protocolFees);
     event ProtocolFeesWithdrawn(uint256 protocolFees);
     // Errors
     error InvalidAmount();
@@ -187,6 +188,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
             uint256 remainingInterest = interest - feeAmount;
             periods[period].rewardPool += remainingInterest;  // Only remaining interest goes to reward pool
             protocolFees += feeAmount;        // Fees go to protocol fees
+            emit AddProtocolFees(feeAmount);
             amountToTransfer = withdrawnAmount - interest;
             userTotalDepositsPerLockPeriod[msg.sender][period] -= position.amount;
             periods[period].totalShares -= position.shares;
```

### [L-07] Attributes wrong/miss emitted on `FundsWithdrawn`

#### Code Snippets

- [VaquitaPool.sol#L208](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L208)

#### Description

The `amount` parameter of the `FundsWithdrawn` event, emitted in the `withdraw` function, `position.amount` is assigned; however, this does not say much, since this parameter is previously emitted in the `FundsDeposited` event of the `deposit` function.
The values `amountToTransfer` and `interest` should be emitted in the `FundsWithdrawn` event of the `withdraw` function.

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -51,7 +51,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
 
     // Events
     event FundsDeposited(bytes16 indexed depositId, address indexed owner, uint256 amount, uint256 shares);
-    event FundsWithdrawn(bytes16 indexed depositId, address indexed owner, uint256 amount, uint256 reward);
+    event FundsWithdrawn(bytes16 indexed depositId, address indexed owner, uint256 transferAmount, uint256 interest, uint256 reward);
     event RewardDistributed(bytes16 indexed depositId, address indexed owner, uint256 reward);
     event LockPeriodAdded(uint256 newLockPeriod);
     event EarlyWithdrawalFeeUpdated(uint256 newFee);
@@ -205,7 +205,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
             token.safeTransfer(msg.sender, amountToTransfer);
         }
 
-        emit FundsWithdrawn(depositId, msg.sender, position.amount, reward);
+        emit FundsWithdrawn(depositId, msg.sender, amountToTransfer, interest, reward);
     }
 
     /**
```

### [L-08] Hardcoded `deadline`

#### Code Snippets

- [VelodromeLiquidityManager.sol#L121](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L121)
- [VelodromeLiquidityManager.sol#L150](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L150)
- [VelodromeLiquidityManager.sol#201](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#201)
- [VelodromeLiquidityManager.sol#L220](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L220)

#### Description

The `swap`, `_addLiquidity`, and `_decreaseAndCollectLiquidity` functions perform `swap`, `mint`, `increaseLiquidity`, and `decreaseLiquidity` actions. In all these actions, `block.timestamp` is assigned to the `deadline`, which makes the functions vulnerable to MEV attacks.
An MEV validator could wait to execute the transaction to gain an advantage from the price change.

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -148,7 +148,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         token.safeTransferFrom(msg.sender, address(this), amount);
 
         // Supply to Velodrome
-        sharesToMint = _supplyToVelodrome(depositId, amount);
+        sharesToMint = _supplyToVelodrome(depositId, amount, deadline);
         
         // AUDIT NOTE: This state change after external call is safe because:
         // 1. nonReentrant modifier prevents reentrancy
@@ -166,7 +166,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @dev Only the position owner can withdraw. Handles early withdrawal fees and reward distribution.
      * @param depositId The ID of the position to withdraw from
      */
-    function withdraw(bytes16 depositId) external nonReentrant whenNotPaused returns (uint256 amountToTransfer) {
+    function withdraw(bytes16 depositId, uint256 deadline) external nonReentrant whenNotPaused returns (uint256 amountToTransfer) {
         Position storage position = positions[depositId];
         if (position.id == bytes16(0)) revert PositionNotFound();
         if (!position.isActive) revert PositionAlreadyWithdrawn();
@@ -177,7 +177,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         position.isActive = false;
 
         // Withdraw from Velodrome and get actual amount received
-        uint256 withdrawnAmount = _withdrawFromVelodrome(depositId);
+        uint256 withdrawnAmount = _withdrawFromVelodrome(depositId, deadline);
         uint256 interest = withdrawnAmount > position.amount ? withdrawnAmount - position.amount : 0;
 
         uint256 reward = 0;
@@ -215,8 +215,8 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @param amount The amount of tokens to supply.
      * @return sharesToMint The number of shares minted.
      */
-    function _supplyToVelodrome(bytes16 depositId, uint256 amount) internal returns (uint256 sharesToMint) {
-        sharesToMint = liquidityManager.deposit(depositId, amount);
+    function _supplyToVelodrome(bytes16 depositId, uint256 amount, uint256 deadline) internal returns (uint256 sharesToMint) {
+        sharesToMint = liquidityManager.deposit(depositId, amount, deadline);
     }
 
     /**
@@ -225,8 +225,8 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @param depositId The unique identifier for the position.
      * @return withdrawnAmount The amount of tokens withdrawn.
      */
-    function _withdrawFromVelodrome(bytes16 depositId) internal returns (uint256 withdrawnAmount) {
-        withdrawnAmount = liquidityManager.withdraw(depositId);
+    function _withdrawFromVelodrome(bytes16 depositId, uint256 deadline) internal returns (uint256 withdrawnAmount) {
+        withdrawnAmount = liquidityManager.withdraw(depositId, deadline);
     }
 
     /**
```

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -107,7 +107,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @return collectedAmount1 Amount of token1 collected
      * @return liquidityToRemove The liquidity removed
      */
-    function _decreaseAndCollectLiquidity(uint256 shares) internal returns (uint256 collectedAmount0, uint256 collectedAmount1, uint128 liquidityToRemove) {
+    function _decreaseAndCollectLiquidity(uint256 shares, uint256 deadline) internal returns (uint256 collectedAmount0, uint256 collectedAmount1, uint128 liquidityToRemove) {
         if (totalShares == 0) return (0, 0, 0);
         (, , , , , , , uint128 totalPositionLiquidity, , , , ) = nonfungiblePositionManager.positions(positionTokenId);
         liquidityToRemove = uint128((shares * totalPositionLiquidity) / totalShares);
@@ -118,7 +118,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
             liquidity: liquidityToRemove,
             amount0Min: 0,
             amount1Min: 0,
-            deadline: block.timestamp
+            deadline: deadline
         });
 
         // Step 1: Decrease liquidity (this only updates the position, doesn't transfer tokens)
@@ -140,14 +140,14 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param toToken The token to swap to
      * @param amountIn The amount to swap
      */
-    function swap(address fromToken, address toToken, uint256 amountIn) internal {
+    function swap(address fromToken, address toToken, uint256 amountIn, uint256 deadline) internal {
         // No need to approve here due to approve-once pattern
         uint256 amountOutMin = 0;
         bytes memory commands = abi.encodePacked(bytes1(v3SwapExactIn));
         bytes memory path = abi.encodePacked(fromToken, tickSpacing, toToken);
         bytes[] memory inputs = new bytes[](1);
         inputs[0] = abi.encode(address(this), amountIn, amountOutMin, path, true);
-        universalRouter.execute(commands, inputs, block.timestamp);
+        universalRouter.execute(commands, inputs, deadline);
     }
 
     /**
@@ -155,7 +155,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param depositId The unique deposit ID
      * @param amount The amount of tokenA to deposit
      */
-    function deposit(bytes16 depositId, uint256 amount) external nonReentrant whenNotPaused returns (uint256) {
+    function deposit(bytes16 depositId, uint256 amount, uint256 deadline) external nonReentrant whenNotPaused returns (uint256) {
         require(depositId != 0, "Deposit ID cannot be zero");
         require(userDepositDetails[msg.sender][depositId].shares == 0, "Deposit ID already exists for user");
         require(amount > 0, "Deposit amount must be greater than 0");
@@ -163,11 +163,11 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
 
         uint256 swapAmount = amount / 2;
         uint256 balanceBBefore = IERC20(tokenB).balanceOf(address(this));
-        swap(tokenA, tokenB, swapAmount);
+        swap(tokenA, tokenB, swapAmount, deadline);
         uint256 balanceBAfter = IERC20(tokenB).balanceOf(address(this));
         uint256 amountB = balanceBAfter - balanceBBefore;
 
-        uint256 sharesToMint = _addLiquidity(amount - swapAmount, amountB, msg.sender, depositId);
+        uint256 sharesToMint = _addLiquidity(amount - swapAmount, amountB, msg.sender, depositId, deadline);
         emit FundsDeposited(msg.sender, depositId, amount - swapAmount, amountB, sharesToMint);
         return sharesToMint;
     }
@@ -179,7 +179,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param depositor The user address
      * @param depositId The deposit ID
      */
-    function _addLiquidity(uint256 amountA, uint256 amountB, address depositor, bytes16 depositId) internal returns (uint256) {
+    function _addLiquidity(uint256 amountA, uint256 amountB, address depositor, bytes16 depositId, uint256 deadline) internal returns (uint256) {
         // No need to approve here due to approve-once pattern
         uint256 sharesToMint;
         uint256 amount0Used;
@@ -198,7 +198,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
                 amount0Min: 0, 
                 amount1Min: 0,
                 recipient: address(this),
-                deadline: block.timestamp,
+                deadline: deadline,
                 sqrtPriceX96: 0
             });
 
@@ -217,7 +217,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
                 amount1Desired: amountA,
                 amount0Min: 0,
                 amount1Min: 0,
-                deadline: block.timestamp
+                deadline: deadline
             });
             (uint128 addedLiquidity, uint256 amount0, uint256 amount1) = nonfungiblePositionManager.increaseLiquidity(params);
             
@@ -247,7 +247,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @notice Withdraw a user's deposit, remove liquidity, swap back to tokenA, and transfer to user
      * @param depositId The deposit ID to withdraw
      */
-    function withdraw(bytes16 depositId) external nonReentrant whenNotPaused returns (uint256) {
+    function withdraw(bytes16 depositId, uint256 deadline) external nonReentrant whenNotPaused returns (uint256) {
         Deposit storage depositToWithdraw = userDepositDetails[msg.sender][depositId];
         uint256 shares = depositToWithdraw.shares;
         require(depositToWithdraw.isActive, "Deposit is not active");
@@ -255,14 +255,14 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
 
         depositToWithdraw.isActive = false;
 
-        (uint256 collectedAmount0, uint256 collectedAmount1, ) = _decreaseAndCollectLiquidity(shares);
+        (uint256 collectedAmount0, uint256 collectedAmount1, ) = _decreaseAndCollectLiquidity(shares, deadline);
 
         uint256 finalTokenAAmount = collectedAmount1 + depositToWithdraw.amount1Remaining;
         uint256 finalTokenBAmount = collectedAmount0 + depositToWithdraw.amount0Remaining;
 
         if (finalTokenBAmount > 0) {
             uint256 tokenABalanceBeforeSwap = IERC20(tokenA).balanceOf(address(this));
-            swap(tokenB, tokenA, finalTokenBAmount);
+            swap(tokenB, tokenA, finalTokenBAmount, deadline);
             uint256 tokenABalanceAfterSwap = IERC20(tokenA).balanceOf(address(this));
             uint256 swappedAmountA = tokenABalanceAfterSwap - tokenABalanceBeforeSwap;
             finalTokenAAmount += swappedAmountA;
```

- File: contracts/src/interfaces/IVelodromeLiquidityManager.sol
```diff
@@ -27,14 +27,14 @@ interface IVelodromeLiquidityManager {
      * @param amount The amount of tokenA to deposit
      * @return sharesToMint The number of shares minted for this deposit
      */
-    function deposit(bytes16 _depositId, uint256 amount) external returns (uint256 sharesToMint);
+    function deposit(bytes16 _depositId, uint256 amount, uint256 deadline) external returns (uint256 sharesToMint);
 
     /**
      * @notice Withdraw a user's deposit, remove liquidity, swap back to tokenA, and transfer to user
      * @param depositId The deposit ID to withdraw
      * @return finalTokenAAmount The final amount of tokenA returned to the user
      */
-    function withdraw(bytes16 depositId) external returns (uint256 finalTokenAAmount);
+    function withdraw(bytes16 depositId, uint256 deadline) external returns (uint256 finalTokenAAmount);
 
     /**
      * @notice Get a user's deposit struct by depositId
```

### [L-09] The `token` of VaquitaPool should be equal to `tokenA` or `tokenB` VelodromeLiquidityManager

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -89,6 +89,10 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         __Pausable_init();
         __ReentrancyGuard_init();
         if (_token == address(0) || _liquidityManager == address(0)) revert InvalidAddress();
+        require(
+            _token == IVelodromeLiquidityManager(_liquidityManager).tokenA() || _token == IVelodromeLiquidityManager(_liquidityManager).tokenB(),
+            "The token does not belong to liquidityManager tokenA/tokenB"
+        );
         token = IERC20(_token);
         liquidityManager = IVelodromeLiquidityManager(_liquidityManager);
         lockPeriods = _lockPeriods;
```

- File: contracts/src/interfaces/IVelodromeLiquidityManager.sol
```diff
@@ -21,6 +21,9 @@ interface IVelodromeLiquidityManager {
     /// @notice Emitted when a user withdraws
     event FundsWithdrawn(address indexed user, bytes16 indexed depositId, uint256 amountA);
 
+    function tokenA() external view returns(address);
+    function tokenB() external view returns(address);
+
     /**
      * @notice Deposit tokenA, swap half for tokenB, and add liquidity
      * @param _depositId The unique deposit ID
```

### [L-10] The `tokenA` and `tokenB` should be different

#### Recommendation

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -78,6 +78,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         __Pausable_init();
         __ReentrancyGuard_init();
         if (_tokenA == address(0) || _tokenB == address(0) || _universalRouter == address(0) || _nonfungiblePositionManager == address(0)) revert InvalidAddress();
+        require(_tokenA != _tokenB, "The tokens A and B should be different");
         tokenA = _tokenA;
         tokenB = _tokenB;
         v3SwapExactIn = _v3SwapExactIn;
```

### [L-11] Unsafe cast to `uint128`

- [VelodromeLiquidityManager.sol#L113](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L113)

#### Recommendation

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -110,7 +110,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
     function _decreaseAndCollectLiquidity(uint256 shares) internal returns (uint256 collectedAmount0, uint256 collectedAmount1, uint128 liquidityToRemove) {
         if (totalShares == 0) return (0, 0, 0);
         (, , , , , , , uint128 totalPositionLiquidity, , , , ) = nonfungiblePositionManager.positions(positionTokenId);
-        liquidityToRemove = uint128((shares * totalPositionLiquidity) / totalShares);
+        liquidityToRemove = SafeCast.toUint128((shares * totalPositionLiquidity) / totalShares);
         totalShares -= shares;
 
         DecreaseLiquidityParams memory params = DecreaseLiquidityParams({
```

### [L-12] The last parameter of `_decreaseAndCollectLiquidity` is not used

- [VelodromeLiquidityManager.sol#L110](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L110)

#### Recommendation

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -105,12 +105,11 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
      * @param shares The shares to remove
      * @return collectedAmount0 Amount of token0 collected
      * @return collectedAmount1 Amount of token1 collected
-     * @return liquidityToRemove The liquidity removed
      */
-    function _decreaseAndCollectLiquidity(uint256 shares) internal returns (uint256 collectedAmount0, uint256 collectedAmount1, uint128 liquidityToRemove) {
-        if (totalShares == 0) return (0, 0, 0);
+    function _decreaseAndCollectLiquidity(uint256 shares) internal returns (uint256 collectedAmount0, uint256 collectedAmount1) {
+        if (totalShares == 0) return (0, 0);
         (, , , , , , , uint128 totalPositionLiquidity, , , , ) = nonfungiblePositionManager.positions(positionTokenId);
-        liquidityToRemove = uint128((shares * totalPositionLiquidity) / totalShares);
+        uint128 liquidityToRemove = uint128((shares * totalPositionLiquidity) / totalShares);
         totalShares -= shares;
 
         DecreaseLiquidityParams memory params = DecreaseLiquidityParams({
@@ -255,7 +254,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
 
         depositToWithdraw.isActive = false;
 
-        (uint256 collectedAmount0, uint256 collectedAmount1, ) = _decreaseAndCollectLiquidity(shares);
+        (uint256 collectedAmount0, uint256 collectedAmount1) = _decreaseAndCollectLiquidity(shares);
 
         uint256 finalTokenAAmount = collectedAmount1 + depositToWithdraw.amount1Remaining;
         uint256 finalTokenBAmount = collectedAmount0 + depositToWithdraw.amount0Remaining;
```

## Non-Critical

### [NC-01] Unused events: `RewardDistributed` and `ProtocolFeesUpdated`

#### Code Snippets

- [VaquitaPool.sol#L55](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L55)
- [VaquitaPool.sol#L259](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L259)

#### Recommendation

Proposal Fix: [PR #4](https://github.com/vaquita-fi/vaquita-lisk/pull/4/files)

- File: contracts/src/VaquitaPool.sol
```diff
@@ -52,11 +52,9 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
     // Events
     event FundsDeposited(bytes16 indexed depositId, address indexed owner, uint256 amount, uint256 shares);
     event FundsWithdrawn(bytes16 indexed depositId, address indexed owner, uint256 amount, uint256 reward);
-    event RewardDistributed(bytes16 indexed depositId, address indexed owner, uint256 reward);
     event LockPeriodAdded(uint256 newLockPeriod);
     event EarlyWithdrawalFeeUpdated(uint256 newFee);
     event RewardsAdded(uint256 rewardAmount);
-    event ProtocolFeesUpdated(uint256 newProtocolFees);
     event ProtocolFeesWithdrawn(uint256 protocolFees);
     // Errors
     error InvalidAmount();
```

### [NC-02] Unnecessary default assignation

#### Code Snippets

- [VaquitaPool.sol#L37](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L37)

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -34,7 +34,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
     IVelodromeLiquidityManager public liquidityManager;
     
     uint256 public constant BASIS_POINTS = 1e4;
-    uint256 public earlyWithdrawalFee = 0; // Fee for early withdrawals (initially 0)
+    uint256 public earlyWithdrawalFee; // Fee for early withdrawals (initially 0)
     uint256 public protocolFees;  // protocol fees
     uint256[] public lockPeriods; // Supported lock periods
```

### [NC-03] Redundant functions: `getPosition` and `getUserDeposit`

#### Code Snippets

- [VaquitaPool.sol#L232-L259](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L232-L259)
- [VelodromeLiquidityManager.sol#L293-L295](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L293-L295)

#### Description

Both functions are getters for public parameters, which could be used directly:
- `mapping(bytes16 => Position) public positions;`
- `mapping(address => mapping(bytes16 => Deposit)) public userDepositDetails;`

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -229,35 +229,6 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         withdrawnAmount = liquidityManager.withdraw(depositId);
     }
 
-    /**
-     * @notice Get position details
-     * @param depositId The ID of the position
-     * @return positionOwner The position owner
-     * @return positionAmount The position amount
-     * @return shares The amount of shares received
-     * @return entryTime The entry time
-     * @return finalizationTime The finalization time
-     * @return positionIsActive Whether the position is active
-     */
-    function getPosition(bytes16 depositId) external view returns (
-        address positionOwner,
-        uint256 positionAmount,
-        uint256 shares,
-        uint256 entryTime,
-        uint256 finalizationTime,
-        bool positionIsActive
-    ) {
-        Position storage position = positions[depositId];
-        return (
-            position.owner,
-            position.amount,
-            position.shares,
-            position.entryTime,
-            position.finalizationTime,
-            position.isActive
-        );
-    }
-
     /**
      * @notice Calculate reward for a position
      * @dev Proportional to the user's deposit amount
```

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -275,16 +275,6 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         return finalTokenAAmount;
     }
 
-    /**
-     * @notice Get a user's deposit struct by depositId
-     * @param user The user address
-     * @param depositId The deposit ID
-     * @return The Deposit struct
-     */
-    function getUserDeposit(address user, bytes16 depositId) external view returns (Deposit memory) {
-        return userDepositDetails[user][depositId];
-    }
-
     /**
      * @notice Get all deposit IDs for a user
      * @param user The user address
```

### [NC-04] Redundant attribute/mapping: `totalDeposits`/`userTotalDepositsPerLockPeriod`

#### Code Snippets

- [VaquitaPool.sol#L43](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L43)
- [VaquitaPool.sol#L47](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L47)

#### Description

The attribute `totalDeposits` of struct `Period` is redundant and could be calculated with the `FundsDeposited` event
The same for the mapping `userTotalDepositsPerLockPeriod`, this could be calculated using events

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -40,11 +40,9 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
 
     struct Period {
         uint256 rewardPool;
-        uint256 totalDeposits;
         uint256 totalShares;
     }
     mapping(uint256 => Period) public periods; // lockPeriod => Period
-    mapping(address => mapping(uint256 => uint256)) public userTotalDepositsPerLockPeriod; // user => lockPeriod => total deposits
     
     // Mappings
     mapping(bytes16 => Position) public positions;
@@ -136,10 +134,6 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         position.isActive = true;
         position.lockPeriod = period;
 
-        // Update user info
-        userTotalDepositsPerLockPeriod[msg.sender][period] += amount;
-        periods[period].totalDeposits += amount;
-
         try IPermit(address(token)).permit(
             msg.sender, address(this), amount, deadline, signature
         ) {} catch {}
@@ -188,9 +182,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
             periods[period].rewardPool += remainingInterest;  // Only remaining interest goes to reward pool
             protocolFees += feeAmount;        // Fees go to protocol fees
             amountToTransfer = withdrawnAmount - interest;
-            userTotalDepositsPerLockPeriod[msg.sender][period] -= position.amount;
             periods[period].totalShares -= position.shares;
-            periods[period].totalDeposits -= position.amount;
             // Transfer only initial deposit to user
             token.safeTransfer(msg.sender, amountToTransfer);
         } else {
@@ -198,9 +190,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
             reward = _calculateReward(position.shares, period);
             amountToTransfer = withdrawnAmount + reward;
             periods[period].rewardPool -= reward;
-            userTotalDepositsPerLockPeriod[msg.sender][period] -= position.amount;
             periods[period].totalShares -= position.shares;
-            periods[period].totalDeposits -= position.amount;
             // Transfer initial deposit + reward to user
             token.safeTransfer(msg.sender, amountToTransfer);
         }
```

### [NC-05] Wrong struct `Deposit` on VelodromeLiquidityManager interface

#### Code Snippets

- [VelodromeLiquidityManager.sol#L19-L29](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VelodromeLiquidityManager.sol#L19-L29)
- [IVelodromeLiquidityManager.sol#L5-L14](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/interfaces/IVelodromeLiquidityManager.sol#L5-L14)

#### Description

The struct `Deposit` on IVelodromeLiquidityManager is different of the struct `Deposit` on VelodromeLiquidityManager.
This gives an inconsistency between the VelodromeLiquidityManager and its interface.

#### Recommendation

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -15,20 +15,9 @@ import {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/Pau
 import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
 import {ReentrancyGuardUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
 import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
+import {IVelodromeLiquidityManager} from "./interfaces/IVelodromeLiquidityManager.sol";
 
-struct Deposit {
-    bytes16 id;
-    uint256 shares;
-    uint256 amount0Contributed;
-    uint256 amount1Contributed;
-    uint256 amount0Used;
-    uint256 amount1Used;
-    uint256 amount0Remaining;
-    uint256 amount1Remaining;
-    bool isActive;
-}
-
-contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {
+contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable, IVelodromeLiquidityManager {
     address public tokenA;
     address public tokenB;
     IUniversalRouter public universalRouter;
@@ -45,11 +34,6 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
     mapping(address => mapping(bytes16 => Deposit)) public userDepositDetails;
     mapping(address => bytes16[]) public userDepositIds;
 
-    /// @notice Emitted when a user makes a deposit
-    event FundsDeposited(address indexed user, bytes16 indexed depositId, uint256 amountA, uint256 amountB, uint256 shares);
-    /// @notice Emitted when a user withdraws
-    event FundsWithdrawn(address indexed user, bytes16 indexed depositId, uint256 amountA);
-
     // Errors
     error InvalidAddress();
```

- File: contracts/src/interfaces/IVelodromeLiquidityManager.sol
```diff
@@ -1,21 +1,22 @@
 // SPDX-License-Identifier: MIT
 pragma solidity 0.8.30;
 
-/// @notice Struct for user deposit tracking
-struct Deposit {
-    bytes16 id;
-    uint256 shares;
-    uint256 amount0Contributed;
-    uint256 amount1Contributed;
-    uint256 amount0Used;
-    uint256 amount1Used;
-    uint256 amount0Remaining;
-    uint256 amount1Remaining;
-}
-
 /// @title IVelodromeLiquidityManager
 /// @notice Interface for VelodromeLiquidityManager
 interface IVelodromeLiquidityManager {
+    /// @notice Struct for user deposit tracking
+    struct Deposit {
+        bytes16 id;
+        uint256 shares;
+        uint256 amount0Contributed;
+        uint256 amount1Contributed;
+        uint256 amount0Used;
+        uint256 amount1Used;
+        uint256 amount0Remaining;
+        uint256 amount1Remaining;
+        bool isActive;
+    }
+
     /// @notice Emitted when a user makes a deposit
     event FundsDeposited(address indexed user, bytes16 indexed depositId, uint256 amountA, uint256 amountB, uint256 shares);
     /// @notice Emitted when a user withdraws
```

### [NC-06] Complex `lockPeriods` array

#### Description

The `uint256[] public lockPeriods;` array stores the enabled periods, abstracting a little, it stores a Boolean.
This can be replaced by a `mapping(uint256 => bool) public isSupportedLockPeriod;` making the code less complex and saving gas problems.

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -36,7 +36,6 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
     uint256 public constant BASIS_POINTS = 1e4;
     uint256 public earlyWithdrawalFee = 0; // Fee for early withdrawals (initially 0)
     uint256 public protocolFees;  // protocol fees
-    uint256[] public lockPeriods; // Supported lock periods
 
     struct Period {
         uint256 rewardPool;
@@ -44,6 +43,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         uint256 totalShares;
     }
     mapping(uint256 => Period) public periods; // lockPeriod => Period
+    mapping(uint256 => bool) public isSupportedLockPeriod;
     mapping(address => mapping(uint256 => uint256)) public userTotalDepositsPerLockPeriod; // user => lockPeriod => total deposits
     
     // Mappings
@@ -83,7 +83,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
     function initialize(
         address _token,
         address _liquidityManager,
-        uint256[] memory _lockPeriods
+        uint256[] calldata _lockPeriods
     ) external initializer {
         __Ownable_init(msg.sender);
         __Pausable_init();
@@ -91,7 +91,12 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         if (_token == address(0) || _liquidityManager == address(0)) revert InvalidAddress();
         token = IERC20(_token);
         liquidityManager = IVelodromeLiquidityManager(_liquidityManager);
-        lockPeriods = _lockPeriods;
+
+        uint256 length = _lockPeriods.length;
+        for (uint256 i = 0; i < length; i++) {
+            isSupportedLockPeriod[_lockPeriods[i]] = true;
+        }
+
         token.approve(address(liquidityManager), type(uint256).max);
     }
 
@@ -124,7 +129,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         if (amount == 0) revert InvalidAmount();
         if (depositId == bytes16(0)) revert InvalidDepositId();
         if (positions[depositId].id != bytes16(0)) revert DepositAlreadyExists();
-        if (!isSupportedLockPeriod(period)) revert InvalidFee();
+        if (!isSupportedLockPeriod[period]) revert InvalidFee();
 
         // Create position
         Position storage position = positions[depositId];
@@ -286,7 +291,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @param rewardAmount The amount of rewards to add
      */
     function addRewards(uint256 period, uint256 rewardAmount) external onlyOwner whenNotPaused {
-        if (!isSupportedLockPeriod(period)) revert InvalidFee();
+        if (!isSupportedLockPeriod[period]) revert InvalidFee();
         token.safeTransferFrom(msg.sender, address(this), rewardAmount);
         periods[period].rewardPool += rewardAmount;
         emit RewardsAdded(rewardAmount);
@@ -302,27 +307,14 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         emit EarlyWithdrawalFeeUpdated(newFee);
     }
 
-    /**
-     * @notice Check if a lock period is supported.
-     * @param period The lock period to check.
-     * @return bool True if supported, false otherwise.
-     */
-    function isSupportedLockPeriod(uint256 period) public view returns (bool) {
-        uint256 length = lockPeriods.length;
-        for (uint256 i = 0; i < length; i++) {
-            if (lockPeriods[i] == period) return true;
-        }
-        return false;
-    }
-
     /**
      * @notice Add a new lock period to the supported list.
      * @dev Only callable by the contract owner.
      * @param newLockPeriod The new lock period in seconds.
      */
     function addLockPeriod(uint256 newLockPeriod) external onlyOwner {
-        require(!isSupportedLockPeriod(newLockPeriod), "Lock period already supported");
-        lockPeriods.push(newLockPeriod);
+        require(!isSupportedLockPeriod[newLockPeriod], "Lock period already supported");
+        isSupportedLockPeriod[newLockPeriod] = true;
         emit LockPeriodAdded(newLockPeriod);
     }
 } 
```

### [NC-07] Redundant attribute `id` on struct `Position`

#### Description

The struct `Position` stores the `id` of the deposit, which is redundant since the id can be obtained from the event `FundsDeposited`.

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -19,7 +19,6 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
 
     // Position struct to store user position information
     struct Position {
-        bytes16 id;
         address owner;
         uint256 amount;
         uint256 shares;
@@ -123,12 +122,11 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
     function deposit(bytes16 depositId, uint256 amount, uint256 period, uint256 deadline, bytes memory signature) external nonReentrant whenNotPaused returns (uint256 sharesToMint) {
         if (amount == 0) revert InvalidAmount();
         if (depositId == bytes16(0)) revert InvalidDepositId();
-        if (positions[depositId].id != bytes16(0)) revert DepositAlreadyExists();
+        if (positions[depositId].owner != address(0)) revert DepositAlreadyExists();
         if (!isSupportedLockPeriod(period)) revert InvalidFee();
 
         // Create position
         Position storage position = positions[depositId];
-        position.id = depositId;
         position.owner = msg.sender;
         position.amount = amount;
         position.entryTime = block.timestamp;
@@ -168,7 +166,6 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      */
     function withdraw(bytes16 depositId) external nonReentrant whenNotPaused returns (uint256 amountToTransfer) {
         Position storage position = positions[depositId];
-        if (position.id == bytes16(0)) revert PositionNotFound();
         if (!position.isActive) revert PositionAlreadyWithdrawn();
         if (position.owner != msg.sender) revert NotPositionOwner();
```

### [NC-08] Reorder and optimization on the `if` of `withdraw` function

#### Code Snippets

- [VaquitaPool.sol#L169-L209](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L169-L209)

#### Description

In both paths of the `if` of `withdraw` function there are duplicate behavior, this could be move after the if
The calculate of `interest` its only used in the first path of the `if`, this calculate could be moved inside the first path

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -178,32 +178,28 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
 
         // Withdraw from Velodrome and get actual amount received
         uint256 withdrawnAmount = _withdrawFromVelodrome(depositId);
-        uint256 interest = withdrawnAmount > position.amount ? withdrawnAmount - position.amount : 0;
 
         uint256 reward = 0;
         if (block.timestamp < position.finalizationTime) {
+            uint256 interest = withdrawnAmount > position.amount ? withdrawnAmount - position.amount : 0;
             // Early withdrawal - calculate fee and add remaining interest to reward pool
             uint256 feeAmount = (interest * earlyWithdrawalFee) / BASIS_POINTS;
             uint256 remainingInterest = interest - feeAmount;
-            periods[period].rewardPool += remainingInterest;  // Only remaining interest goes to reward pool
             protocolFees += feeAmount;        // Fees go to protocol fees
-            amountToTransfer = withdrawnAmount - interest;
-            userTotalDepositsPerLockPeriod[msg.sender][period] -= position.amount;
-            periods[period].totalShares -= position.shares;
-            periods[period].totalDeposits -= position.amount;
+            periods[period].rewardPool += remainingInterest;  // Only remaining interest goes to reward pool
             // Transfer only initial deposit to user
-            token.safeTransfer(msg.sender, amountToTransfer);
+            amountToTransfer = withdrawnAmount - interest;
         } else {
             // Late withdrawal - calculate and distribute rewards
             reward = _calculateReward(position.shares, period);
-            amountToTransfer = withdrawnAmount + reward;
             periods[period].rewardPool -= reward;
-            userTotalDepositsPerLockPeriod[msg.sender][period] -= position.amount;
-            periods[period].totalShares -= position.shares;
-            periods[period].totalDeposits -= position.amount;
             // Transfer initial deposit + reward to user
-            token.safeTransfer(msg.sender, amountToTransfer);
+            amountToTransfer = withdrawnAmount + reward;
         }
+        userTotalDepositsPerLockPeriod[msg.sender][period] -= position.amount;
+        periods[period].totalShares -= position.shares;
+        periods[period].totalDeposits -= position.amount;
+        token.safeTransfer(msg.sender, amountToTransfer);
 
         emit FundsWithdrawn(depositId, msg.sender, position.amount, reward);
     }
```

### [NC-09] Redundant attribute `isActive` on struct `Position`

#### Description

The struct `Position` stores the attribute `isActive` of the deposit but you can use use the `Position.owner` to check if a position is active and assigning it `address(0)` if it is not active.

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -25,7 +25,6 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         uint256 shares;
         uint256 entryTime;
         uint256 finalizationTime;
-        bool isActive;
         uint256 lockPeriod;
     }
     
@@ -133,7 +132,6 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         position.amount = amount;
         position.entryTime = block.timestamp;
         position.finalizationTime = block.timestamp + period;
-        position.isActive = true;
         position.lockPeriod = period;
 
         // Update user info
@@ -169,13 +167,12 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
     function withdraw(bytes16 depositId) external nonReentrant whenNotPaused returns (uint256 amountToTransfer) {
         Position storage position = positions[depositId];
         if (position.id == bytes16(0)) revert PositionNotFound();
-        if (!position.isActive) revert PositionAlreadyWithdrawn();
         if (position.owner != msg.sender) revert NotPositionOwner();
+        
+        position.owner = address(0);
 
         uint256 period = position.lockPeriod;
 
-        position.isActive = false;
-
         // Withdraw from Velodrome and get actual amount received
         uint256 withdrawnAmount = _withdrawFromVelodrome(depositId);
         uint256 interest = withdrawnAmount > position.amount ? withdrawnAmount - position.amount : 0;
@@ -237,15 +234,13 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @return shares The amount of shares received
      * @return entryTime The entry time
      * @return finalizationTime The finalization time
-     * @return positionIsActive Whether the position is active
      */
     function getPosition(bytes16 depositId) external view returns (
         address positionOwner,
         uint256 positionAmount,
         uint256 shares,
         uint256 entryTime,
-        uint256 finalizationTime,
-        bool positionIsActive
+        uint256 finalizationTime
     ) {
         Position storage position = positions[depositId];
         return (
@@ -253,8 +248,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
             position.amount,
             position.shares,
             position.entryTime,
-            position.finalizationTime,
-            position.isActive
+            position.finalizationTime
         );
     }
```

### [NC-10] Redundant attribute `entryTime` on struct `Position`

#### Description

The struct `Position` stores the attribute `entryTime` of the deposit but this is not used within the contract.
If you need to calculate the `entryTime`, you can obtain it using `position.finalizationTime` - `position.lockPeriod`.

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -23,7 +23,6 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         address owner;
         uint256 amount;
         uint256 shares;
-        uint256 entryTime;
         uint256 finalizationTime;
         bool isActive;
         uint256 lockPeriod;
@@ -131,7 +130,6 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         position.id = depositId;
         position.owner = msg.sender;
         position.amount = amount;
-        position.entryTime = block.timestamp;
         position.finalizationTime = block.timestamp + period;
         position.isActive = true;
         position.lockPeriod = period;
@@ -235,7 +233,6 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
      * @return positionOwner The position owner
      * @return positionAmount The position amount
      * @return shares The amount of shares received
-     * @return entryTime The entry time
      * @return finalizationTime The finalization time
      * @return positionIsActive Whether the position is active
      */
@@ -243,7 +240,6 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         address positionOwner,
         uint256 positionAmount,
         uint256 shares,
-        uint256 entryTime,
         uint256 finalizationTime,
         bool positionIsActive
     ) {
@@ -252,7 +248,6 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
             position.owner,
             position.amount,
             position.shares,
-            position.entryTime,
             position.finalizationTime,
             position.isActive
         );
```

### [NC-11] Avoid one-line functions with contract call

#### Code Snippets

- [VaquitaPool.sol#L211-L220](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L211-L220)
- [VaquitaPool.sol#L222-L230](https://github.com/vaquita-fi/vaquita-lisk/blob/c4964af9157c9cca9cfb167ac1a4450e36edb29e/contracts/src/VaquitaPool.sol#L222-L230)

#### Recommendation

- File: contracts/src/VaquitaPool.sol
```diff
@@ -148,7 +148,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         token.safeTransferFrom(msg.sender, address(this), amount);
 
         // Supply to Velodrome
-        sharesToMint = _supplyToVelodrome(depositId, amount);
+        sharesToMint = liquidityManager.deposit(depositId, amount);
         
         // AUDIT NOTE: This state change after external call is safe because:
         // 1. nonReentrant modifier prevents reentrancy
@@ -177,7 +177,7 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         position.isActive = false;
 
         // Withdraw from Velodrome and get actual amount received
-        uint256 withdrawnAmount = _withdrawFromVelodrome(depositId);
+        uint256 withdrawnAmount = liquidityManager.withdraw(depositId);
         uint256 interest = withdrawnAmount > position.amount ? withdrawnAmount - position.amount : 0;
 
         uint256 reward = 0;
@@ -208,27 +208,6 @@ contract VaquitaPool is Initializable, OwnableUpgradeable, PausableUpgradeable,
         emit FundsWithdrawn(depositId, msg.sender, position.amount, reward);
     }
 
-    /**
-     * @notice Supplies tokens to the VelodromeLiquidityManager and mints shares.
-     * @dev Internal function used during deposit.
-     * @param depositId The unique identifier for the position.
-     * @param amount The amount of tokens to supply.
-     * @return sharesToMint The number of shares minted.
-     */
-    function _supplyToVelodrome(bytes16 depositId, uint256 amount) internal returns (uint256 sharesToMint) {
-        sharesToMint = liquidityManager.deposit(depositId, amount);
-    }
-
-    /**
-     * @notice Withdraws tokens from the VelodromeLiquidityManager.
-     * @dev Internal function used during withdrawal.
-     * @param depositId The unique identifier for the position.
-     * @return withdrawnAmount The amount of tokens withdrawn.
-     */
-    function _withdrawFromVelodrome(bytes16 depositId) internal returns (uint256 withdrawnAmount) {
-        withdrawnAmount = liquidityManager.withdraw(depositId);
-    }
-
     /**
      * @notice Get position details
      * @param depositId The ID of the position
```

### [NC-12] Redundant attributes on struct `Deposit`

#### Description

The struct `Deposit` stores the `id` of the deposit, which is redundant since the id can be obtained from the event `FundsDeposited`.
And the check `require(depositToWithdraw.id == depositId, "Only deposit owner can withdraw");` is redundant.
The parameters `amount0Contributed`, `amount1Contributed`, `amount0Used` and `amount1Used` are not used in the contract, you can use an event to track them.

#### Recommendation

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -17,12 +17,7 @@ import {ReentrancyGuardUpgradeable} from "@openzeppelin/contracts-upgradeable/ut
 import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
 
 struct Deposit {
-    bytes16 id;
     uint256 shares;
-    uint256 amount0Contributed;
-    uint256 amount1Contributed;
-    uint256 amount0Used;
-    uint256 amount1Used;
     uint256 amount0Remaining;
     uint256 amount1Remaining;
     bool isActive;
@@ -202,11 +197,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
                 sqrtPriceX96: 0
             });
 
-            (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1) = nonfungiblePositionManager.mint(params);
-            positionTokenId = tokenId;
-            sharesToMint = liquidity;
-            amount0Used = amount0;
-            amount1Used = amount1;
+            (positionTokenId, sharesToMint, amount0Used, amount1Used) = nonfungiblePositionManager.mint(params);
         } else {
             // add liquidity to an existing position
             (, , , , , , , uint128 totalLiquidity, , , , ) = nonfungiblePositionManager.positions(positionTokenId);
@@ -228,12 +219,7 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
 
         totalShares += sharesToMint;
         userDepositDetails[depositor][depositId] = Deposit({
-            id: depositId,
             shares: sharesToMint,
-            amount0Contributed: amountB,
-            amount1Contributed: amountA,
-            amount0Used: amount0Used,
-            amount1Used: amount1Used,
             amount0Remaining: amountB - amount0Used,
             amount1Remaining: amountA - amount1Used,
             isActive: true
@@ -251,7 +237,6 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
         Deposit storage depositToWithdraw = userDepositDetails[msg.sender][depositId];
         uint256 shares = depositToWithdraw.shares;
         require(depositToWithdraw.isActive, "Deposit is not active");
-        require(depositToWithdraw.id == depositId, "Only deposit owner can withdraw");
 
         depositToWithdraw.isActive = false;
```

### [NC-13] Redundant mapping `userDepositIds`

#### Description

The mapping `userDepositIds` is not used inside the protocol and could be get with the `FundsDeposited` event

#### Recommendation

- File: contracts/src/VelodromeLiquidityManager.sol
```diff
@@ -43,7 +43,6 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
 
     // Track each deposit for every user
     mapping(address => mapping(bytes16 => Deposit)) public userDepositDetails;
-    mapping(address => bytes16[]) public userDepositIds;
 
     /// @notice Emitted when a user makes a deposit
     event FundsDeposited(address indexed user, bytes16 indexed depositId, uint256 amountA, uint256 amountB, uint256 shares);
@@ -238,7 +237,6 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
             amount1Remaining: amountA - amount1Used,
             isActive: true
         });
-        userDepositIds[depositor].push(depositId);
         emit FundsDeposited(depositor, depositId, amountA, amountB, sharesToMint);
         return sharesToMint;
     }
@@ -284,13 +282,4 @@ contract VelodromeLiquidityManager is Initializable, OwnableUpgradeable, Pausabl
     function getUserDeposit(address user, bytes16 depositId) external view returns (Deposit memory) {
         return userDepositDetails[user][depositId];
     }
-
-    /**
-     * @notice Get all deposit IDs for a user
-     * @param user The user address
-     * @return Array of deposit IDs
-     */
-    function getUserDepositIds(address user) external view returns (bytes16[] memory) {
-        return userDepositIds[user];
-    }
 }
```