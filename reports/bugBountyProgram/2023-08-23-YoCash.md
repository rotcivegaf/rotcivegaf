# Stuck funds in contract **Bankroll** and all contracts inherited from contract **Common**

- Protocol: [YoCash](https://yoca.sh/)
- Severity: Critical

## Target(s)

- [https://github.com/yocashofficial/play](https://github.com/yocashofficial/play)

## Impact(s)

- Permanent freezing of funds

## Bug Description

The contracts **Bankroll** and **Common** have the function `withdrawToken` who perform an ERC20 transfer with a require, but some tokens like `BNB` or `USDT` don't returns a `bool`

https://github.com/yocashofficial/play/blob/d6ae50c3578e42663d707f661d2b3cfd096a142c/contracts/Games/Bankroll/Bankroll.sol#L116-L121 

https://github.com/yocashofficial/play/blob/d6ae50c3578e42663d707f661d2b3cfd096a142c/contracts/Games/Common.sol#L180-L185

```solidity
    function withdrawToken(address _token, uint256 _amount) external onlyOwner {
        require(
            IERC20(_token).transfer(msg.sender, _amount),
            "Transfer failed"
        );
    }
```

If the ERC20 don't returns true the function `withdrawToken` revert with "Transfer failed" message and the founds go stuck forever in the contract

> Note: In the description of the bounty says "The platform operates on EVM-based blockchains and accepts native coins or tokens for transactions."

### Impact Details

Stuck funds in contract **Bankroll** and all contracts inherited from contract **Common**

### Recommendation

Use [`safeTransfer` from the `SafeERC20` library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/9e3f4d60c581010c4a3979480e07cc7752f124cc/contracts/token/ERC20/utils/SafeERC20.sol#L32-L38) instead of transfer

### References

- [https://github.com/d-xo/weird-erc20 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/9e3f4d60c581010c4a3979480e07cc7752f124cc/contracts/token/ERC20/utils/SafeERC20.sol#L32-L38](https://github.com/d-xo/weird-erc20 https://github.com/OpenZeppelin/openzeppelin-contracts/blob/9e3f4d60c581010c4a3979480e07cc7752f124cc/contracts/token/ERC20/utils/SafeERC20.sol#L32-L38)

## Proof of Concept

```solidity
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "forge-std/StdUtils.sol";

import {SafeERC20, IERC20} from "openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol";
import {ReentrancyGuard} from "openzeppelin-contracts/contracts/security/ReentrancyGuard.sol";

contract PoC is Test {
    address USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;

    function setUp() public {
        vm.selectFork(vm.createFork("https://eth.llamarpc.com"));
    }

    function testTryWithdrawUSDTFromBankroll() public {
        Bankroll bankroll = new Bankroll();
        deal(USDT, address(this), 10 ether);

        IUSDT(USDT).transfer(address(bankroll), 10 ether);

        bankroll.withdrawToken(USDT, 1 ether);
    }

    function testTryWithdrawUSDTFromCommon() public {
        CoinFlip coinFlip = new CoinFlip(
            address(0),
            bytes32(0),
            uint64(0),
            address(0),
            address(0)
        );

        deal(USDT, address(this), 10 ether);

        IUSDT(USDT).transfer(address(coinFlip), 10 ether);

        coinFlip.withdrawToken(USDT, 1 ether);
    }
}

// Interfaces

interface IUSDT {
    function transfer(address _to, uint _value) external;
}

interface AggregatorV3Interface {
    function latestRoundData() external view returns (
        uint80, int256 answer, uint256, uint256, uint80
    );
}

interface VRFCoordinatorV2Interface {
    function requestRandomWords(
        bytes32 keyHash,
        uint64 subId,
        uint16 minimumRequestConfirmations,
        uint32 callbackGasLimit,
        uint32 numWords
    ) external returns (uint256 requestId);
}

interface IVRFCoordinatorV2 is VRFCoordinatorV2Interface {
    function getFeeConfig() external view returns (
        uint32 fulfillmentFlatFeeLinkPPMTier1, uint32, uint32, uint32, uint32, uint24, uint24, uint24, uint24
    );
}

interface IBankRoll {
    function getIsGame(address game) external view returns (bool);

    function getIsValidWager(
        address game,
        address tokenAddress
    ) external view returns (bool);

    function transferPayout(
        address player,
        uint256 payout,
        address token
    ) external;

    function viewOwner() external view returns (address);

    function isPlayerSuspended(
        address player
    ) external view returns (bool, uint256);

    function viewAllowedTokens() external view returns (address[] memory);

    function getIsTokenAllowed(
        address tokenAddress
    ) external view returns (bool);
}

// From: https://github.com/yocashofficial/play/blob/d6ae50c3578e42663d707f661d2b3cfd096a142c/contracts/Games/Common.sol#L1-L212

contract Bankroll {
    using SafeERC20 for IERC20;

    mapping(address => bool) isGame;
    mapping(address => bool) isTokenAllowed;
    mapping(address => uint256) suspendedTime;
    mapping(address => bool) suspendedPlayers;

    address public ownerAddress;
    address[] allowedTokens;

    event nativeTokenTransferFailed(address indexed player, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == ownerAddress, "Not Owner");
        _;
    }

    constructor() {
        ownerAddress = msg.sender;
    }

    function getIsValidWager(
        address game,
        address tokenAddress
    ) external view returns (bool) {
        return (isGame[game] && isTokenAllowed[tokenAddress]);
    }

    function setTokenAddress(
        address tokenAddress,
        bool isValid
    ) external onlyOwner {
        isTokenAllowed[tokenAddress] = isValid;
        allowedTokens.push(tokenAddress);
    }

    function transferPayout(
        address player,
        uint256 payout,
        address tokenAddress
    ) external {
        require(isGame[msg.sender], "Not a valid game");
        if (tokenAddress != address(0)) {
            IERC20(tokenAddress).safeTransfer(player, payout);
        } else {
            (bool success, ) = payable(player).call{value: payout, gas: 2400}(
                ""
            );
            if (!success) {
                emit nativeTokenTransferFailed(player, payout);
            }
        }
    }

    function setPlayerSuspended(
        uint256 suspensionTime,
        address _player
    ) external onlyOwner {
        require(suspendedTime[_player] > block.timestamp, "Already Suspended");
        suspendedTime[_player] = block.timestamp + suspensionTime;
        suspendedPlayers[_player] = true;
    }

    function setPlayerSuspensionTime(
        uint256 suspensionTime,
        address _player
    ) external onlyOwner {
        suspendedTime[_player] += suspensionTime;
        suspendedPlayers[_player] = true;
    }

    function setPlayerBanned(address _player) external onlyOwner {
        suspendedTime[_player] = 2 ** 256 - 1;
        suspendedPlayers[_player] = true;
    }

    function setPlayerNotSuspended(address _player) external onlyOwner {
        require(suspendedTime[_player] > block.timestamp, "Not suspended");
        suspendedPlayers[_player] = false;
    }

    function setGame(address game, bool _state) external onlyOwner {
        isGame[game] = _state;
    }

    function getIsGame(address game) external view returns (bool) {
        return isGame[game];
    }

    function getIsTokenAllowed(
        address tokenAddress
    ) external view returns (bool) {
        return isTokenAllowed[tokenAddress];
    }

    function isPlayerSuspended(
        address player
    ) external view returns (bool, uint256) {
        return (suspendedPlayers[player], suspendedTime[player]);
    }

    function viewAllowedTokens() external view returns (address[] memory) {
        return allowedTokens;
    }

    function viewOwner() external view returns (address) {
        return ownerAddress;
    }

    function withdrawToken(address _token, uint256 _amount) external onlyOwner {
        require(
            IERC20(_token).transfer(msg.sender, _amount),
            "Transfer failed"
        );
    }

    function withdrawEth(uint256 _amount) external onlyOwner {
        (bool success, ) = payable(msg.sender).call{value: _amount}("");
        require(success, "Transfer failed");
    }

    receive() external payable {}
}

contract Common is ReentrancyGuard {
    using SafeERC20 for IERC20;

    uint256 public VRFFees;
    address public ChainLinkVRF;
    bytes32 chainlinkVRFKeyHash;
    uint64 chainlinkVRFSubscriptionId;

    AggregatorV3Interface public LINK_ETH_FEED;
    IVRFCoordinatorV2 public IChainLinkVRF;
    IBankRoll public Bankroll;

    error NotApprovedBankroll();
    error InvalidValue(uint256 required, uint256 sent);
    error TransferFailed();
    error RefundFailed();
    error NotOwner(address want, address have);
    error ZeroWager();
    error PlayerSuspended(uint256 suspensionTime);

    modifier onlyOwner() {
        if (msg.sender != Bankroll.viewOwner()) {
            revert NotOwner(Bankroll.viewOwner(), msg.sender);
        }
        _;
    }

    function _transferWager(
        address tokenAddress,
        uint256 wager,
        uint256 gasAmount,
        address msgSender
    ) internal returns (uint256 VRFfee) {
        if (!Bankroll.getIsValidWager(address(this), tokenAddress)) {
            revert NotApprovedBankroll();
        }
        if (wager == 0) {
            revert ZeroWager();
        }
        (bool suspended, uint256 suspendedTime) = Bankroll.isPlayerSuspended(
            msgSender
        );
        if (suspended) {
            revert PlayerSuspended(suspendedTime);
        }
        VRFfee = getVRFFee(gasAmount);

        if (tokenAddress == address(0)) {
            if (msg.value < wager + VRFfee) {
                revert InvalidValue(wager + VRFfee, msg.value);
            }
            _refundExcessValue(msg.value - (VRFfee + wager));
        } else {
            if (msg.value < VRFfee) {
                revert InvalidValue(VRFfee, msg.value);
            }

            IERC20(tokenAddress).safeTransferFrom(
                msgSender,
                address(this),
                wager
            );

            _refundExcessValue(msg.value - VRFfee);
        }
        VRFFees += VRFfee;
    }

    function _transferToBankroll(
        address tokenAddress,
        uint256 amount
    ) internal {
        if (tokenAddress == address(0)) {
            (bool success, ) = payable(address(Bankroll)).call{value: amount}(
                ""
            );
            if (!success) {
                revert RefundFailed();
            }
        } else {
            IERC20(tokenAddress).safeTransfer(address(Bankroll), amount);
        }
    }

    function getVRFFee(uint256 gasAmount) public view returns (uint256 fee) {
        (, int256 answer, , , ) = LINK_ETH_FEED.latestRoundData();
        (uint32 fulfillmentFlatFeeLinkPPMTier1, , , , , , , , ) = IChainLinkVRF
            .getFeeConfig();

        fee =
            tx.gasprice *
            (gasAmount) +
            ((1e12 *
                uint256(fulfillmentFlatFeeLinkPPMTier1) *
                uint256(answer)) / 1e18);
    }

    function _refundExcessValue(uint256 refund) internal {
        if (refund == 0) {
            return;
        }
        (bool success, ) = payable(msg.sender).call{value: refund}("");
        if (!success) {
            revert RefundFailed();
        }
    }

    function _payVRFFee(uint256 gasAmount) internal returns (uint256 VRFfee) {
        VRFfee = getVRFFee(gasAmount);
        if (msg.value < VRFfee) {
            revert InvalidValue(VRFfee, msg.value);
        }
        _refundExcessValue(msg.value - VRFfee);
        VRFFees += VRFfee;
    }

    function transferFees(address to) external onlyOwner {
        uint256 fee = VRFFees;
        VRFFees = 0;
        (bool success, ) = payable(address(to)).call{value: fee}("");
        if (!success) {
            revert TransferFailed();
        }
    }

    function withdrawToken(address _token, uint256 _amount) external onlyOwner {
        require(
            IERC20(_token).transfer(msg.sender, _amount),
            "Transfer failed"
        );
    }

    function withdrawEth(uint256 _amount) external onlyOwner {
        (bool success, ) = payable(msg.sender).call{value: _amount}("");
        require(success, "Transfer failed");
    }

    function _transferPayout(
        address player,
        uint256 payout,
        address tokenAddress
    ) internal {
        Bankroll.transferPayout(player, payout, tokenAddress);
    }

    function _requestRandomWords(
        uint32 numWords
    ) internal returns (uint256 s_requestId) {
        s_requestId = VRFCoordinatorV2Interface(ChainLinkVRF)
            .requestRandomWords(
                chainlinkVRFKeyHash,
                chainlinkVRFSubscriptionId,
                3,
                2500000,
                numWords
            );
    }
}

contract CoinFlip is Common {
    using SafeERC20 for IERC20;

    constructor(
        address _chainlinkVRF,
        bytes32 _chainlinkVRFKeyHash,
        uint64 _chainlinkVRFSubscriptionId,
        address _bankroll,
        address link_eth_feed
    ) {
        Bankroll = IBankRoll(_bankroll);
        IChainLinkVRF = IVRFCoordinatorV2(_chainlinkVRF);
        LINK_ETH_FEED = AggregatorV3Interface(link_eth_feed);
        ChainLinkVRF = _chainlinkVRF;
        chainlinkVRFKeyHash = _chainlinkVRFKeyHash;
        chainlinkVRFSubscriptionId = _chainlinkVRFSubscriptionId;
    }

    struct CoinFlipGame {
        uint256 wager;
        uint256 stopGain;
        uint256 stopLoss;
        uint256 requestID;
        address tokenAddress;
        uint64 blockNumber;
        uint32 numBets;
        bool isHeads;
    }

    mapping(address => CoinFlipGame) coinFlipGames;
    mapping(uint256 => address) coinIDs;

    event gamePlayEvent(
        address indexed playerAddress,
        uint256 wager,
        address tokenAddress,
        bool isHeads,
        uint32 numBets,
        uint256 stopGain,
        uint256 stopLoss,
        uint256 VRFFee
    );

    event gameOutcomeEvent(
        address indexed playerAddress,
        uint256 wager,
        uint256 payout,
        address tokenAddress,
        uint8[] coinOutcomes,
        uint256[] payouts,
        uint32 numGames
    );

    event gameRefundEvent(
        address indexed player,
        uint256 wager,
        address tokenAddress
    );

    error WagerAboveLimit(uint256 wager, uint256 maxWager);
    error AwaitingVRF(uint256 requestID);
    error InvalidNumBets(uint256 maxNumBets);
    error NotAwaitingVRF();
    error BlockNumberTooLow(uint256 have, uint256 want);
    error OnlyCoordinatorCanFulfill(address have, address want);

    function gameGetState(
        address player
    ) external view returns (CoinFlipGame memory) {
        return (coinFlipGames[player]);
    }

    function gamePlay(
        uint256 wager,
        address tokenAddress,
        bool isHeads,
        uint32 numBets,
        uint256 stopGain,
        uint256 stopLoss
    ) external payable nonReentrant {
        address msgSender = msg.sender;
        if (coinFlipGames[msgSender].requestID != 0) {
            revert AwaitingVRF(coinFlipGames[msgSender].requestID);
        }
        if (!(numBets > 0 && numBets <= 100)) {
            revert InvalidNumBets(100);
        }

        _checkWager(wager, tokenAddress);
        uint256 fee = _transferWager(
            tokenAddress,
            wager * numBets,
            1000000,
            msgSender
        );

        uint256 id = _requestRandomWords(numBets);

        coinFlipGames[msgSender] = CoinFlipGame(
            wager,
            stopGain,
            stopLoss,
            id,
            tokenAddress,
            uint64(block.number),
            numBets,
            isHeads
        );
        coinIDs[id] = msgSender;

        emit gamePlayEvent(
            msgSender,
            wager,
            tokenAddress,
            isHeads,
            numBets,
            stopGain,
            stopLoss,
            fee
        );
    }

    function gameRefund() external nonReentrant {
        require(tx.origin == msg.sender, "no contracts refunds allowed");  // this is intended and will be compensated manually
        CoinFlipGame storage game = coinFlipGames[msg.sender];
        if (game.requestID == 0) {
            revert NotAwaitingVRF();
        }
        if (game.blockNumber + 200 > block.number) {
            revert BlockNumberTooLow(block.number, game.blockNumber + 200);
        }

        uint256 wager = game.wager * game.numBets;
        address tokenAddress = game.tokenAddress;

        delete (coinIDs[game.requestID]);
        delete (coinFlipGames[msg.sender]);

        if (tokenAddress == address(0)) {
            (bool success, ) = payable(msg.sender).call{value: wager}("");
            if (!success) {
                revert TransferFailed();
            }
        } else {
            IERC20(tokenAddress).safeTransfer(msg.sender, wager);
        }
        emit gameRefundEvent(msg.sender, wager, tokenAddress);
    }

    function rawFulfillRandomWords(
        uint256 requestId,
        uint256[] memory randomWords
    ) external {
        if (msg.sender != ChainLinkVRF) {
            revert OnlyCoordinatorCanFulfill(msg.sender, ChainLinkVRF);
        }

        fulfillRandomWords(requestId, randomWords);
    }

    function fulfillRandomWords(
        uint256 requestId,
        uint256[] memory randomWords
    ) internal {
        address playerAddress = coinIDs[requestId];
        if (playerAddress == address(0)) revert();
        CoinFlipGame storage game = coinFlipGames[playerAddress];

        int256 totalValue;
        uint256 payout;
        uint32 i;
        uint8[] memory coinFlip = new uint8[](game.numBets);
        uint256[] memory payouts = new uint256[](game.numBets);

        address tokenAddress = game.tokenAddress;

        for (i = 0; i < game.numBets; i++) {
            if (totalValue >= int256(game.stopGain)) {
                break;
            }
            if (totalValue <= -int256(game.stopLoss)) {
                break;
            }

            coinFlip[i] = uint8(randomWords[i] % 2);

            if (coinFlip[i] == 1 && game.isHeads == true) {
                totalValue += int256((game.wager * 9800) / 10000);
                payout += (game.wager * 19800) / 10000;
                payouts[i] = (game.wager * 19800) / 10000;
                continue;
            }
            if (coinFlip[i] == 0 && game.isHeads == false) {
                totalValue += int256((game.wager * 9800) / 10000);
                payout += (game.wager * 19800) / 10000;
                payouts[i] = (game.wager * 19800) / 10000;
                continue;
            }

            totalValue -= int256(game.wager);
        }

        payout += (game.numBets - i) * game.wager;

        emit gameOutcomeEvent(
            playerAddress,
            game.wager,
            payout,
            tokenAddress,
            coinFlip,
            payouts,
            i
        );
        _transferToBankroll(tokenAddress, game.wager * game.numBets);
        delete (coinIDs[requestId]);
        delete (coinFlipGames[playerAddress]);
        if (payout != 0) {
            _transferPayout(playerAddress, payout, tokenAddress);
        }
    }

    function _checkWager(uint256 wager, address tokenAddress) internal view {
        uint256 maxWager = getMaxWager(tokenAddress);
        if (wager > maxWager) {
            revert WagerAboveLimit(wager, maxWager);
        }
    }

    function getMaxWager(address tokenAddress) public view returns (uint256) {
        uint256 balance;
        if (tokenAddress == address(0)) {
            balance = address(Bankroll).balance;
        } else {
            balance = IERC20(tokenAddress).balanceOf(address(Bankroll));
        }
        uint256 maxWager = (balance * 1122448) / 100000000;
        return maxWager;
    }

    function getGameInfos()
        external
        view
        returns (address[] memory, uint256[] memory)
    {
        address[] memory allTokens = Bankroll.viewAllowedTokens();
        address[] memory tokens = new address[](allTokens.length + 1);
        uint256[] memory maxWagers = new uint256[](allTokens.length + 1);
        uint256 i = 0;

        for (i; i < allTokens.length; i++) {
            if (Bankroll.getIsTokenAllowed(allTokens[i])) {
                tokens[i] = allTokens[i];
                maxWagers[i] = getMaxWager(allTokens[i]);
            }
        }
        tokens[i] = address(0);
        maxWagers[i] = getMaxWager(address(0));

        return (tokens, maxWagers);
    }
}
```

## Info after reported

this is duplicate of report ######